
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>17.3. ssl — TLS/SSL wrapper for socket objects &mdash; Editorial Documentation</title>
    <link rel="stylesheet" href="../_static/pythonista.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Editorial Documentation"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Editorial Documentation" href="../index.html" />
    <link rel="up" title="17. Interprocess Communication and Networking" href="ipc.html" />
    <link rel="next" title="17.4. signal — Set handlers for asynchronous events" href="signal.html" />
    <link rel="prev" title="17.2. socket — Low-level networking interface" href="socket.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <meta name = "viewport" content = "width=device-width; initial-scale=1.0; minimum-scale=1.0; maximum-scale=1.0">
    
    <script type="text/javascript">
        var getTextForSample = function(i) {
            codeBlock = document.getElementsByClassName('highlight-python')[i];
            return codeBlock.innerText;
        }
        
        var copySample = function (i) {
            window.location.href = '/__pythonista_copy__/' + encodeURI(getTextForSample(i));
        }
        
        var openSample = function (i) {
            window.location.href = '/__pythonista_open__/' + encodeURI(getTextForSample(i));
        }
        
        //Source: http://ejohn.org/blog/partial-functions-in-javascript/
        Function.prototype.partial = function() {
        	var fn = this,
        		args = Array.prototype.slice.call(arguments);
        	return function() {
        		var arg = 0;
        		for (var i = 0; i < args.length && arg < arguments.length; i++)
        		if (args[i] === undefined) args[i] = arguments[arg++];
        		return fn.apply(this, args);
        	};
        };
        
        window.onload=function() {
            //Add "Copy" and "Open in Editor" buttons for code samples:
            var inApp = navigator.userAgent.match(/AppleWebKit/i) != null && navigator.userAgent.match(/Safari/i) == null;
            if (inApp) {
                codeBlocks = document.getElementsByClassName('highlight-python');
                for (var i = 0; i < codeBlocks.length; i++) {
                    codeBlock = codeBlocks[i];
                    if (codeBlock.innerText.indexOf('>>>') == 0) {
                        //Don't add header for interactive sessions
                        continue;
                    }

                    var codeHeader = document.createElement('div');
                    codeHeader.className = 'pythonista-code-header';

                    var copyButton = document.createElement('button');
                    copyButton.className = 'pythonista-button';
                    copyButton.innerText = 'Copy';
                    copyButton.addEventListener('click', copySample.partial(i));
                    codeHeader.appendChild(copyButton);

                    codeBlock.parentElement.insertBefore(codeHeader, codeBlock);
                }
            }
        }
    </script>
    
 

  </head>
  <body ontouchstart="">
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="signal.html" title="17.4. signal — Set handlers for asynchronous events"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="socket.html" title="17.2. socket — Low-level networking interface"
             accesskey="P">previous</a> |</li>
        <li><a href="../../../editorial.html"><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -4px; margin-right: 4px;"/></a></li>
        <li><a href="../index.html">Editorial Documentation</a> &raquo;</li>

          <li><a href="index.html" >The Python Standard Library</a> &raquo;</li>
          <li><a href="ipc.html" accesskey="U">17. Interprocess Communication and Networking</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="module-ssl">
<span id="ssl-tls-ssl-wrapper-for-socket-objects"></span><h1>17.3. <a class="reference internal" href="ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><tt class="xref py py-mod docutils literal"><span class="pre">ssl</span></tt></a> &#8212; TLS/SSL wrapper for socket objects<a class="headerlink" href="ssl.html#module-ssl" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-0"></span><p class="versionadded" id="index-1">
<span class="versionmodified">New in version 2.6.</span></p>
<p><strong>Source code:</strong> <a class="reference external" href="http://hg.python.org/cpython/file/2.7/Lib/ssl.py">Lib/ssl.py</a></p>
<hr class="docutils" />
<p>This module provides access to Transport Layer Security (often known as &#8220;Secure
Sockets Layer&#8221;) encryption and peer authentication facilities for network
sockets, both client-side and server-side.  This module uses the OpenSSL
library. It is available on all modern Unix systems, Windows, Mac OS X, and
probably additional platforms, as long as OpenSSL is installed on that platform.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Some behavior may be platform dependent, since calls are made to the
operating system socket APIs.  The installed version of OpenSSL may also
cause variations in behavior.</p>
</div>
<p>This section documents the objects and functions in the <tt class="docutils literal"><span class="pre">ssl</span></tt> module; for more
general information about TLS, SSL, and certificates, the reader is referred to
the documents in the &#8220;See Also&#8221; section at the bottom.</p>
<p>This module provides a class, <tt class="xref py py-class docutils literal"><span class="pre">ssl.SSLSocket</span></tt>, which is derived from the
<a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><tt class="xref py py-class docutils literal"><span class="pre">socket.socket</span></tt></a> type, and provides a socket-like wrapper that also
encrypts and decrypts the data going over the socket with SSL.  It supports
additional <tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">write()</span></tt> methods, along with a method,
<tt class="xref py py-meth docutils literal"><span class="pre">getpeercert()</span></tt>, to retrieve the certificate of the other side of the
connection, and a method, <tt class="xref py py-meth docutils literal"><span class="pre">cipher()</span></tt>, to retrieve the cipher being used for
the secure connection.</p>
<div class="section" id="functions-constants-and-exceptions">
<h2>17.3.1. Functions, Constants, and Exceptions<a class="headerlink" href="ssl.html#functions-constants-and-exceptions" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="ssl.SSLError">
<em class="property">exception </em><tt class="descclassname">ssl.</tt><tt class="descname">SSLError</tt><a class="headerlink" href="ssl.html#ssl.SSLError" title="Permalink to this definition">¶</a></dt>
<dd><p>Raised to signal an error from the underlying SSL implementation.  This
signifies some problem in the higher-level encryption and authentication
layer that&#8217;s superimposed on the underlying network connection.  This error
is a subtype of <a class="reference internal" href="socket.html#socket.error" title="socket.error"><tt class="xref py py-exc docutils literal"><span class="pre">socket.error</span></tt></a>, which in turn is a subtype of
<a class="reference internal" href="exceptions.html#exceptions.IOError" title="exceptions.IOError"><tt class="xref py py-exc docutils literal"><span class="pre">IOError</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="ssl.wrap_socket">
<tt class="descclassname">ssl.</tt><tt class="descname">wrap_socket</tt><big>(</big><em>sock</em>, <em>keyfile=None</em>, <em>certfile=None</em>, <em>server_side=False</em>, <em>cert_reqs=CERT_NONE</em>, <em>ssl_version={see docs}</em>, <em>ca_certs=None</em>, <em>do_handshake_on_connect=True</em>, <em>suppress_ragged_eofs=True</em>, <em>ciphers=None</em><big>)</big><a class="headerlink" href="ssl.html#ssl.wrap_socket" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes an instance <tt class="docutils literal"><span class="pre">sock</span></tt> of <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><tt class="xref py py-class docutils literal"><span class="pre">socket.socket</span></tt></a>, and returns an instance
of <tt class="xref py py-class docutils literal"><span class="pre">ssl.SSLSocket</span></tt>, a subtype of <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><tt class="xref py py-class docutils literal"><span class="pre">socket.socket</span></tt></a>, which wraps
the underlying socket in an SSL context.  For client-side sockets, the
context construction is lazy; if the underlying socket isn&#8217;t connected yet,
the context construction will be performed after <tt class="xref py py-meth docutils literal"><span class="pre">connect()</span></tt> is called on
the socket.  For server-side sockets, if the socket has no remote peer, it is
assumed to be a listening socket, and the server-side SSL wrapping is
automatically performed on client connections accepted via the <tt class="xref py py-meth docutils literal"><span class="pre">accept()</span></tt>
method.  <a class="reference internal" href="ssl.html#ssl.wrap_socket" title="ssl.wrap_socket"><tt class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></tt></a> may raise <a class="reference internal" href="ssl.html#ssl.SSLError" title="ssl.SSLError"><tt class="xref py py-exc docutils literal"><span class="pre">SSLError</span></tt></a>.</p>
<p>The <tt class="docutils literal"><span class="pre">keyfile</span></tt> and <tt class="docutils literal"><span class="pre">certfile</span></tt> parameters specify optional files which
contain a certificate to be used to identify the local side of the
connection.  See the discussion of <a class="reference internal" href="ssl.html#ssl-certificates"><em>Certificates</em></a> for more
information on how the certificate is stored in the <tt class="docutils literal"><span class="pre">certfile</span></tt>.</p>
<p>Often the private key is stored in the same file as the certificate; in this
case, only the <tt class="docutils literal"><span class="pre">certfile</span></tt> parameter need be passed.  If the private key is
stored in a separate file, both parameters must be used.  If the private key
is stored in the <tt class="docutils literal"><span class="pre">certfile</span></tt>, it should come before the first certificate in
the certificate chain:</p>
<div class="highlight-python"><pre>-----BEGIN RSA PRIVATE KEY-----
... (private key in base64 encoding) ...
-----END RSA PRIVATE KEY-----
-----BEGIN CERTIFICATE-----
... (certificate in base64 PEM encoding) ...
-----END CERTIFICATE-----</pre>
</div>
<p>The parameter <tt class="docutils literal"><span class="pre">server_side</span></tt> is a boolean which identifies whether
server-side or client-side behavior is desired from this socket.</p>
<p>The parameter <tt class="docutils literal"><span class="pre">cert_reqs</span></tt> specifies whether a certificate is required from
the other side of the connection, and whether it will be validated if
provided.  It must be one of the three values <a class="reference internal" href="ssl.html#ssl.CERT_NONE" title="ssl.CERT_NONE"><tt class="xref py py-const docutils literal"><span class="pre">CERT_NONE</span></tt></a>
(certificates ignored), <a class="reference internal" href="ssl.html#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><tt class="xref py py-const docutils literal"><span class="pre">CERT_OPTIONAL</span></tt></a> (not required, but validated
if provided), or <a class="reference internal" href="ssl.html#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><tt class="xref py py-const docutils literal"><span class="pre">CERT_REQUIRED</span></tt></a> (required and validated).  If the
value of this parameter is not <a class="reference internal" href="ssl.html#ssl.CERT_NONE" title="ssl.CERT_NONE"><tt class="xref py py-const docutils literal"><span class="pre">CERT_NONE</span></tt></a>, then the <tt class="docutils literal"><span class="pre">ca_certs</span></tt>
parameter must point to a file of CA certificates.</p>
<p>The <tt class="docutils literal"><span class="pre">ca_certs</span></tt> file contains a set of concatenated &#8220;certification
authority&#8221; certificates, which are used to validate certificates passed from
the other end of the connection.  See the discussion of
<a class="reference internal" href="ssl.html#ssl-certificates"><em>Certificates</em></a> for more information about how to arrange the
certificates in this file.</p>
<p>The parameter <tt class="docutils literal"><span class="pre">ssl_version</span></tt> specifies which version of the SSL protocol to
use.  Typically, the server chooses a particular protocol version, and the
client must adapt to the server&#8217;s choice.  Most of the versions are not
interoperable with the other versions.  If not specified, the default is
<a class="reference internal" href="ssl.html#ssl.PROTOCOL_SSLv23" title="ssl.PROTOCOL_SSLv23"><tt class="xref py py-data docutils literal"><span class="pre">PROTOCOL_SSLv23</span></tt></a>; it provides the most compatibility with other
versions.</p>
<p>Here&#8217;s a table showing which versions in a client (down the side) can connect
to which versions in a server (along the top):</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="15%" />
<col width="15%" />
<col width="16%" />
<col width="15%" />
</colgroup>
<tbody valign="top">
<tr><td><em>client</em> / <strong>server</strong></td>
<td><strong>SSLv2</strong></td>
<td><strong>SSLv3</strong></td>
<td><strong>SSLv23</strong></td>
<td><strong>TLSv1</strong></td>
</tr>
<tr><td><em>SSLv2</em></td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>no</td>
</tr>
<tr><td><em>SSLv3</em></td>
<td>no</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
<tr><td><em>SSLv23</em></td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>no</td>
</tr>
<tr><td><em>TLSv1</em></td>
<td>no</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
</tr>
</tbody>
</table>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Which connections succeed will vary depending on the version of
OpenSSL.  For instance, in some older versions of OpenSSL (such
as 0.9.7l on OS X 10.4), an SSLv2 client could not connect to an
SSLv23 server.  Another example: beginning with OpenSSL 1.0.0,
an SSLv23 client will not actually attempt SSLv2 connections
unless you explicitly enable SSLv2 ciphers; for example, you
might specify <tt class="docutils literal"><span class="pre">&quot;ALL&quot;</span></tt> or <tt class="docutils literal"><span class="pre">&quot;SSLv2&quot;</span></tt> as the <em>ciphers</em> parameter
to enable them.</p>
</div>
<p>The <em>ciphers</em> parameter sets the available ciphers for this SSL object.
It should be a string in the <a class="reference external" href="http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT">OpenSSL cipher list format</a>.</p>
<p>The parameter <tt class="docutils literal"><span class="pre">do_handshake_on_connect</span></tt> specifies whether to do the SSL
handshake automatically after doing a <tt class="xref py py-meth docutils literal"><span class="pre">socket.connect()</span></tt>, or whether the
application program will call it explicitly, by invoking the
<a class="reference internal" href="ssl.html#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><tt class="xref py py-meth docutils literal"><span class="pre">SSLSocket.do_handshake()</span></tt></a> method.  Calling
<a class="reference internal" href="ssl.html#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><tt class="xref py py-meth docutils literal"><span class="pre">SSLSocket.do_handshake()</span></tt></a> explicitly gives the program control over the
blocking behavior of the socket I/O involved in the handshake.</p>
<p>The parameter <tt class="docutils literal"><span class="pre">suppress_ragged_eofs</span></tt> specifies how the
<a class="reference internal" href="ssl.html#ssl.SSLSocket.read" title="ssl.SSLSocket.read"><tt class="xref py py-meth docutils literal"><span class="pre">SSLSocket.read()</span></tt></a> method should signal unexpected EOF from the other end
of the connection.  If specified as <a class="reference internal" href="constants.html#True" title="True"><tt class="xref py py-const xref docutils literal"><span class="pre">True</span></tt></a> (the default), it returns a
normal EOF in response to unexpected EOF errors raised from the underlying
socket; if <a class="reference internal" href="constants.html#False" title="False"><tt class="xref py py-const xref docutils literal"><span class="pre">False</span></tt></a>, it will raise the exceptions back to the caller.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 2.7: </span>New optional argument <em>ciphers</em>.</p>
</dd></dl>

<dl class="function">
<dt id="ssl.RAND_status">
<tt class="descclassname">ssl.</tt><tt class="descname">RAND_status</tt><big>(</big><big>)</big><a class="headerlink" href="ssl.html#ssl.RAND_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the SSL pseudo-random number generator has been seeded with
&#8216;enough&#8217; randomness, and False otherwise.  You can use <a class="reference internal" href="ssl.html#ssl.RAND_egd" title="ssl.RAND_egd"><tt class="xref py py-func docutils literal"><span class="pre">ssl.RAND_egd()</span></tt></a>
and <a class="reference internal" href="ssl.html#ssl.RAND_add" title="ssl.RAND_add"><tt class="xref py py-func docutils literal"><span class="pre">ssl.RAND_add()</span></tt></a> to increase the randomness of the pseudo-random
number generator.</p>
</dd></dl>

<dl class="function">
<dt id="ssl.RAND_egd">
<tt class="descclassname">ssl.</tt><tt class="descname">RAND_egd</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="ssl.html#ssl.RAND_egd" title="Permalink to this definition">¶</a></dt>
<dd><p>If you are running an entropy-gathering daemon (EGD) somewhere, and <tt class="docutils literal"><span class="pre">path</span></tt>
is the pathname of a socket connection open to it, this will read 256 bytes
of randomness from the socket, and add it to the SSL pseudo-random number
generator to increase the security of generated secret keys.  This is
typically only necessary on systems without better sources of randomness.</p>
<p>See <a class="reference external" href="http://egd.sourceforge.net/">http://egd.sourceforge.net/</a> or <a class="reference external" href="http://prngd.sourceforge.net/">http://prngd.sourceforge.net/</a> for sources
of entropy-gathering daemons.</p>
</dd></dl>

<dl class="function">
<dt id="ssl.RAND_add">
<tt class="descclassname">ssl.</tt><tt class="descname">RAND_add</tt><big>(</big><em>bytes</em>, <em>entropy</em><big>)</big><a class="headerlink" href="ssl.html#ssl.RAND_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Mixes the given <tt class="docutils literal"><span class="pre">bytes</span></tt> into the SSL pseudo-random number generator.  The
parameter <tt class="docutils literal"><span class="pre">entropy</span></tt> (a float) is a lower bound on the entropy contained in
string (so you can always use <tt class="xref py py-const docutils literal"><span class="pre">0.0</span></tt>).  See <span class="target" id="index-2"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc1750.html"><strong>RFC 1750</strong></a> for more
information on sources of entropy.</p>
</dd></dl>

<dl class="function">
<dt id="ssl.cert_time_to_seconds">
<tt class="descclassname">ssl.</tt><tt class="descname">cert_time_to_seconds</tt><big>(</big><em>timestring</em><big>)</big><a class="headerlink" href="ssl.html#ssl.cert_time_to_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a floating-point value containing a normal seconds-after-the-epoch
time value, given the time-string representing the &#8220;notBefore&#8221; or &#8220;notAfter&#8221;
date from a certificate.</p>
<p>Here&#8217;s an example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ssl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">cert_time_to_seconds</span><span class="p">(</span><span class="s">&quot;May  9 00:00:00 2007 GMT&quot;</span><span class="p">)</span>
<span class="go">1178694000.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">cert_time_to_seconds</span><span class="p">(</span><span class="s">&quot;May  9 00:00:00 2007 GMT&quot;</span><span class="p">))</span>
<span class="go">&#39;Wed May  9 00:00:00 2007&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.get_server_certificate">
<tt class="descclassname">ssl.</tt><tt class="descname">get_server_certificate</tt><big>(</big><em>addr</em>, <em>ssl_version=PROTOCOL_SSLv3</em>, <em>ca_certs=None</em><big>)</big><a class="headerlink" href="ssl.html#ssl.get_server_certificate" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the address <tt class="docutils literal"><span class="pre">addr</span></tt> of an SSL-protected server, as a (<em>hostname</em>,
<em>port-number</em>) pair, fetches the server&#8217;s certificate, and returns it as a
PEM-encoded string.  If <tt class="docutils literal"><span class="pre">ssl_version</span></tt> is specified, uses that version of
the SSL protocol to attempt to connect to the server.  If <tt class="docutils literal"><span class="pre">ca_certs</span></tt> is
specified, it should be a file containing a list of root certificates, the
same format as used for the same parameter in <a class="reference internal" href="ssl.html#ssl.wrap_socket" title="ssl.wrap_socket"><tt class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></tt></a>.  The call
will attempt to validate the server certificate against that set of root
certificates, and will fail if the validation attempt fails.</p>
</dd></dl>

<dl class="function">
<dt id="ssl.DER_cert_to_PEM_cert">
<tt class="descclassname">ssl.</tt><tt class="descname">DER_cert_to_PEM_cert</tt><big>(</big><em>DER_cert_bytes</em><big>)</big><a class="headerlink" href="ssl.html#ssl.DER_cert_to_PEM_cert" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded
string version of the same certificate.</p>
</dd></dl>

<dl class="function">
<dt id="ssl.PEM_cert_to_DER_cert">
<tt class="descclassname">ssl.</tt><tt class="descname">PEM_cert_to_DER_cert</tt><big>(</big><em>PEM_cert_string</em><big>)</big><a class="headerlink" href="ssl.html#ssl.PEM_cert_to_DER_cert" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a certificate as an ASCII PEM string, returns a DER-encoded sequence of
bytes for that same certificate.</p>
</dd></dl>

<dl class="data">
<dt id="ssl.CERT_NONE">
<tt class="descclassname">ssl.</tt><tt class="descname">CERT_NONE</tt><a class="headerlink" href="ssl.html#ssl.CERT_NONE" title="Permalink to this definition">¶</a></dt>
<dd><p>Value to pass to the <tt class="docutils literal"><span class="pre">cert_reqs</span></tt> parameter to <tt class="xref py py-func docutils literal"><span class="pre">sslobject()</span></tt> when no
certificates will be required or validated from the other side of the socket
connection.</p>
</dd></dl>

<dl class="data">
<dt id="ssl.CERT_OPTIONAL">
<tt class="descclassname">ssl.</tt><tt class="descname">CERT_OPTIONAL</tt><a class="headerlink" href="ssl.html#ssl.CERT_OPTIONAL" title="Permalink to this definition">¶</a></dt>
<dd><p>Value to pass to the <tt class="docutils literal"><span class="pre">cert_reqs</span></tt> parameter to <tt class="xref py py-func docutils literal"><span class="pre">sslobject()</span></tt> when no
certificates will be required from the other side of the socket connection,
but if they are provided, will be validated.  Note that use of this setting
requires a valid certificate validation file also be passed as a value of the
<tt class="docutils literal"><span class="pre">ca_certs</span></tt> parameter.</p>
</dd></dl>

<dl class="data">
<dt id="ssl.CERT_REQUIRED">
<tt class="descclassname">ssl.</tt><tt class="descname">CERT_REQUIRED</tt><a class="headerlink" href="ssl.html#ssl.CERT_REQUIRED" title="Permalink to this definition">¶</a></dt>
<dd><p>Value to pass to the <tt class="docutils literal"><span class="pre">cert_reqs</span></tt> parameter to <tt class="xref py py-func docutils literal"><span class="pre">sslobject()</span></tt> when
certificates will be required from the other side of the socket connection.
Note that use of this setting requires a valid certificate validation file
also be passed as a value of the <tt class="docutils literal"><span class="pre">ca_certs</span></tt> parameter.</p>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_SSLv2">
<tt class="descclassname">ssl.</tt><tt class="descname">PROTOCOL_SSLv2</tt><a class="headerlink" href="ssl.html#ssl.PROTOCOL_SSLv2" title="Permalink to this definition">¶</a></dt>
<dd><p>Selects SSL version 2 as the channel encryption protocol.</p>
<p>This protocol is not available if OpenSSL is compiled with OPENSSL_NO_SSL2
flag.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">SSL version 2 is insecure.  Its use is highly discouraged.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_SSLv23">
<tt class="descclassname">ssl.</tt><tt class="descname">PROTOCOL_SSLv23</tt><a class="headerlink" href="ssl.html#ssl.PROTOCOL_SSLv23" title="Permalink to this definition">¶</a></dt>
<dd><p>Selects SSL version 2 or 3 as the channel encryption protocol.  This is a
setting to use with servers for maximum compatibility with the other end of
an SSL connection, but it may cause the specific ciphers chosen for the
encryption to be of fairly low quality.</p>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_SSLv3">
<tt class="descclassname">ssl.</tt><tt class="descname">PROTOCOL_SSLv3</tt><a class="headerlink" href="ssl.html#ssl.PROTOCOL_SSLv3" title="Permalink to this definition">¶</a></dt>
<dd><p>Selects SSL version 3 as the channel encryption protocol.  For clients, this
is the maximally compatible SSL variant.</p>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_TLSv1">
<tt class="descclassname">ssl.</tt><tt class="descname">PROTOCOL_TLSv1</tt><a class="headerlink" href="ssl.html#ssl.PROTOCOL_TLSv1" title="Permalink to this definition">¶</a></dt>
<dd><p>Selects TLS version 1 as the channel encryption protocol.  This is the most
modern version, and probably the best choice for maximum protection, if both
sides can speak it.</p>
</dd></dl>

<dl class="data">
<dt id="ssl.OPENSSL_VERSION">
<tt class="descclassname">ssl.</tt><tt class="descname">OPENSSL_VERSION</tt><a class="headerlink" href="ssl.html#ssl.OPENSSL_VERSION" title="Permalink to this definition">¶</a></dt>
<dd><p>The version string of the OpenSSL library loaded by the interpreter:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION</span>
<span class="go">&#39;OpenSSL 0.9.8k 25 Mar 2009&#39;</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<dl class="data">
<dt id="ssl.OPENSSL_VERSION_INFO">
<tt class="descclassname">ssl.</tt><tt class="descname">OPENSSL_VERSION_INFO</tt><a class="headerlink" href="ssl.html#ssl.OPENSSL_VERSION_INFO" title="Permalink to this definition">¶</a></dt>
<dd><p>A tuple of five integers representing version information about the
OpenSSL library:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION_INFO</span>
<span class="go">(0, 9, 8, 11, 15)</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

<dl class="data">
<dt id="ssl.OPENSSL_VERSION_NUMBER">
<tt class="descclassname">ssl.</tt><tt class="descname">OPENSSL_VERSION_NUMBER</tt><a class="headerlink" href="ssl.html#ssl.OPENSSL_VERSION_NUMBER" title="Permalink to this definition">¶</a></dt>
<dd><p>The raw version number of the OpenSSL library, as a single integer:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION_NUMBER</span>
<span class="go">9470143L</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION_NUMBER</span><span class="p">)</span>
<span class="go">&#39;0x9080bfL&#39;</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">New in version 2.7.</span></p>
</dd></dl>

</div>
<div class="section" id="sslsocket-objects">
<h2>17.3.2. SSLSocket Objects<a class="headerlink" href="ssl.html#sslsocket-objects" title="Permalink to this headline">¶</a></h2>
<dl class="method">
<dt id="ssl.SSLSocket.read">
<tt class="descclassname">SSLSocket.</tt><tt class="descname">read</tt><big>(</big><span class="optional">[</span><em>nbytes=1024</em><span class="optional">]</span><big>)</big><a class="headerlink" href="ssl.html#ssl.SSLSocket.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads up to <tt class="docutils literal"><span class="pre">nbytes</span></tt> bytes from the SSL-encrypted channel and returns them.</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.write">
<tt class="descclassname">SSLSocket.</tt><tt class="descname">write</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="ssl.html#ssl.SSLSocket.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the <tt class="docutils literal"><span class="pre">data</span></tt> to the other side of the connection, using the SSL
channel to encrypt.  Returns the number of bytes written.</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.getpeercert">
<tt class="descclassname">SSLSocket.</tt><tt class="descname">getpeercert</tt><big>(</big><em>binary_form=False</em><big>)</big><a class="headerlink" href="ssl.html#ssl.SSLSocket.getpeercert" title="Permalink to this definition">¶</a></dt>
<dd><p>If there is no certificate for the peer on the other end of the connection,
returns <tt class="xref docutils literal"><span class="pre">None</span></tt>.</p>
<p>If the parameter <tt class="docutils literal"><span class="pre">binary_form</span></tt> is <a class="reference internal" href="constants.html#False" title="False"><tt class="xref py py-const xref docutils literal"><span class="pre">False</span></tt></a>, and a certificate was
received from the peer, this method returns a <a class="reference internal" href="stdtypes.html#dict" title="dict"><tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt></a> instance.  If the
certificate was not validated, the dict is empty.  If the certificate was
validated, it returns a dict with the keys <tt class="docutils literal"><span class="pre">subject</span></tt> (the principal for
which the certificate was issued), and <tt class="docutils literal"><span class="pre">notAfter</span></tt> (the time after which the
certificate should not be trusted).  The certificate was already validated,
so the <tt class="docutils literal"><span class="pre">notBefore</span></tt> and <tt class="docutils literal"><span class="pre">issuer</span></tt> fields are not returned.  If a
certificate contains an instance of the <em>Subject Alternative Name</em> extension
(see <span class="target" id="index-3"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc3280.html"><strong>RFC 3280</strong></a>), there will also be a <tt class="docutils literal"><span class="pre">subjectAltName</span></tt> key in the
dictionary.</p>
<p>The &#8220;subject&#8221; field is a tuple containing the sequence of relative
distinguished names (RDNs) given in the certificate&#8217;s data structure for the
principal, and each RDN is a sequence of name-value pairs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">{</span><span class="s">&#39;notAfter&#39;</span><span class="p">:</span> <span class="s">&#39;Feb 16 16:54:50 2013 GMT&#39;</span><span class="p">,</span>
 <span class="s">&#39;subject&#39;</span><span class="p">:</span> <span class="p">(((</span><span class="s">&#39;countryName&#39;</span><span class="p">,</span> <span class="s">u&#39;US&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;stateOrProvinceName&#39;</span><span class="p">,</span> <span class="s">u&#39;Delaware&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;localityName&#39;</span><span class="p">,</span> <span class="s">u&#39;Wilmington&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;organizationName&#39;</span><span class="p">,</span> <span class="s">u&#39;Python Software Foundation&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;organizationalUnitName&#39;</span><span class="p">,</span> <span class="s">u&#39;SSL&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;commonName&#39;</span><span class="p">,</span> <span class="s">u&#39;somemachine.python.org&#39;</span><span class="p">),))}</span>
</pre></div>
</div>
<p>If the <tt class="docutils literal"><span class="pre">binary_form</span></tt> parameter is <a class="reference internal" href="constants.html#True" title="True"><tt class="xref py py-const xref docutils literal"><span class="pre">True</span></tt></a>, and a certificate was
provided, this method returns the DER-encoded form of the entire certificate
as a sequence of bytes, or <a class="reference internal" href="constants.html#None" title="None"><tt class="xref py py-const xref docutils literal"><span class="pre">None</span></tt></a> if the peer did not provide a
certificate.  This return value is independent of validation; if validation
was required (<a class="reference internal" href="ssl.html#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><tt class="xref py py-const docutils literal"><span class="pre">CERT_OPTIONAL</span></tt></a> or <a class="reference internal" href="ssl.html#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><tt class="xref py py-const docutils literal"><span class="pre">CERT_REQUIRED</span></tt></a>), it will have
been validated, but if <a class="reference internal" href="ssl.html#ssl.CERT_NONE" title="ssl.CERT_NONE"><tt class="xref py py-const docutils literal"><span class="pre">CERT_NONE</span></tt></a> was used to establish the
connection, the certificate, if present, will not have been validated.</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.cipher">
<tt class="descclassname">SSLSocket.</tt><tt class="descname">cipher</tt><big>(</big><big>)</big><a class="headerlink" href="ssl.html#ssl.SSLSocket.cipher" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a three-value tuple containing the name of the cipher being used, the
version of the SSL protocol that defines its use, and the number of secret
bits being used.  If no connection has been established, returns <tt class="xref docutils literal"><span class="pre">None</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.do_handshake">
<tt class="descclassname">SSLSocket.</tt><tt class="descname">do_handshake</tt><big>(</big><big>)</big><a class="headerlink" href="ssl.html#ssl.SSLSocket.do_handshake" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a TLS/SSL handshake.  If this is used with a non-blocking socket, it
may raise <a class="reference internal" href="ssl.html#ssl.SSLError" title="ssl.SSLError"><tt class="xref py py-exc docutils literal"><span class="pre">SSLError</span></tt></a> with an <tt class="docutils literal"><span class="pre">arg[0]</span></tt> of <tt class="xref py py-const docutils literal"><span class="pre">SSL_ERROR_WANT_READ</span></tt>
or <tt class="xref py py-const docutils literal"><span class="pre">SSL_ERROR_WANT_WRITE</span></tt>, in which case it must be called again until
it completes successfully.  For example, to simulate the behavior of a
blocking socket, one might write:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">do_handshake</span><span class="p">()</span>
        <span class="k">break</span>
    <span class="k">except</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">err</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSL_ERROR_WANT_READ</span><span class="p">:</span>
            <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="n">s</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[])</span>
        <span class="k">elif</span> <span class="n">err</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSL_ERROR_WANT_WRITE</span><span class="p">:</span>
            <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([],</span> <span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="p">[])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.unwrap">
<tt class="descclassname">SSLSocket.</tt><tt class="descname">unwrap</tt><big>(</big><big>)</big><a class="headerlink" href="ssl.html#ssl.SSLSocket.unwrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the SSL shutdown handshake, which removes the TLS layer from the
underlying socket, and returns the underlying socket object.  This can be
used to go from encrypted operation over a connection to unencrypted.  The
socket instance returned should always be used for further communication with
the other side of the connection, rather than the original socket instance
(which may not function properly after the unwrap).</p>
</dd></dl>

<span class="target" id="index-4"></span></div>
<div class="section" id="certificates">
<span id="ssl-certificates"></span><span id="index-5"></span><h2>17.3.3. Certificates<a class="headerlink" href="ssl.html#certificates" title="Permalink to this headline">¶</a></h2>
<p>Certificates in general are part of a public-key / private-key system.  In this
system, each <em>principal</em>, (which may be a machine, or a person, or an
organization) is assigned a unique two-part encryption key.  One part of the key
is public, and is called the <em>public key</em>; the other part is kept secret, and is
called the <em>private key</em>.  The two parts are related, in that if you encrypt a
message with one of the parts, you can decrypt it with the other part, and
<strong>only</strong> with the other part.</p>
<p>A certificate contains information about two principals.  It contains the name
of a <em>subject</em>, and the subject&#8217;s public key.  It also contains a statement by a
second principal, the <em>issuer</em>, that the subject is who he claims to be, and
that this is indeed the subject&#8217;s public key.  The issuer&#8217;s statement is signed
with the issuer&#8217;s private key, which only the issuer knows.  However, anyone can
verify the issuer&#8217;s statement by finding the issuer&#8217;s public key, decrypting the
statement with it, and comparing it to the other information in the certificate.
The certificate also contains information about the time period over which it is
valid.  This is expressed as two fields, called &#8220;notBefore&#8221; and &#8220;notAfter&#8221;.</p>
<p>In the Python use of certificates, a client or server can use a certificate to
prove who they are.  The other side of a network connection can also be required
to produce a certificate, and that certificate can be validated to the
satisfaction of the client or server that requires such validation.  The
connection attempt can be set to raise an exception if the validation fails.
Validation is done automatically, by the underlying OpenSSL framework; the
application need not concern itself with its mechanics.  But the application
does usually need to provide sets of certificates to allow this process to take
place.</p>
<p>Python uses files to contain certificates.  They should be formatted as &#8220;PEM&#8221;
(see <span class="target" id="index-6"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc1422.html"><strong>RFC 1422</strong></a>), which is a base-64 encoded form wrapped with a header line
and a footer line:</p>
<div class="highlight-python"><pre>-----BEGIN CERTIFICATE-----
... (certificate in base64 PEM encoding) ...
-----END CERTIFICATE-----</pre>
</div>
<p>The Python files which contain certificates can contain a sequence of
certificates, sometimes called a <em>certificate chain</em>.  This chain should start
with the specific certificate for the principal who &#8220;is&#8221; the client or server,
and then the certificate for the issuer of that certificate, and then the
certificate for the issuer of <em>that</em> certificate, and so on up the chain till
you get to a certificate which is <em>self-signed</em>, that is, a certificate which
has the same subject and issuer, sometimes called a <em>root certificate</em>.  The
certificates should just be concatenated together in the certificate file.  For
example, suppose we had a three certificate chain, from our server certificate
to the certificate of the certification authority that signed our server
certificate, to the root certificate of the agency which issued the
certification authority&#8217;s certificate:</p>
<div class="highlight-python"><pre>-----BEGIN CERTIFICATE-----
... (certificate for your server)...
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
... (the certificate for the CA)...
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
... (the root certificate for the CA's issuer)...
-----END CERTIFICATE-----</pre>
</div>
<p>If you are going to require validation of the other side of the connection&#8217;s
certificate, you need to provide a &#8220;CA certs&#8221; file, filled with the certificate
chains for each issuer you are willing to trust.  Again, this file just contains
these chains concatenated together.  For validation, Python will use the first
chain it finds in the file which matches.</p>
<p>Some &#8220;standard&#8221; root certificates are available from various certification
authorities: <a class="reference external" href="http://www.cacert.org/index.php?id=3">CACert.org</a>, <a class="reference external" href="http://www.thawte.com/roots/">Thawte</a>, <a class="reference external" href="http://www.verisign.com/support/roots.html">Verisign</a>, <a class="reference external" href="http://www.PositiveSSL.com/ssl-certificate-support/cert_installation/UTN-USERFirst-Hardware.crt">Positive SSL</a>
(used by python.org), <a class="reference external" href="http://www.geotrust.com/resources/root_certificates/index.asp">Equifax and GeoTrust</a>.</p>
<p>In general, if you are using SSL3 or TLS1, you don&#8217;t need to put the full chain
in your &#8220;CA certs&#8221; file; you only need the root certificates, and the remote
peer is supposed to furnish the other certificates necessary to chain from its
certificate to a root certificate.  See <span class="target" id="index-7"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc4158.html"><strong>RFC 4158</strong></a> for more discussion of the
way in which certification chains can be built.</p>
<p>If you are going to create a server that provides SSL-encrypted connection
services, you will need to acquire a certificate for that service.  There are
many ways of acquiring appropriate certificates, such as buying one from a
certification authority.  Another common practice is to generate a self-signed
certificate.  The simplest way to do this is with the OpenSSL package, using
something like the following:</p>
<div class="highlight-python"><pre>% openssl req -new -x509 -days 365 -nodes -out cert.pem -keyout cert.pem
Generating a 1024 bit RSA private key
.......++++++
.............................++++++
writing new private key to 'cert.pem'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:US
State or Province Name (full name) [Some-State]:MyState
Locality Name (eg, city) []:Some City
Organization Name (eg, company) [Internet Widgits Pty Ltd]:My Organization, Inc.
Organizational Unit Name (eg, section) []:My Group
Common Name (eg, YOUR name) []:myserver.mygroup.myorganization.com
Email Address []:ops@myserver.mygroup.myorganization.com
%</pre>
</div>
<p>The disadvantage of a self-signed certificate is that it is its own root
certificate, and no one else will have it in their cache of known (and trusted)
root certificates.</p>
</div>
<div class="section" id="examples">
<h2>17.3.4. Examples<a class="headerlink" href="ssl.html#examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="testing-for-ssl-support">
<h3>17.3.4.1. Testing for SSL support<a class="headerlink" href="ssl.html#testing-for-ssl-support" title="Permalink to this headline">¶</a></h3>
<p>To test for the presence of SSL support in a Python installation, user code
should use the following idiom:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">ssl</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="k">else</span><span class="p">:</span>
    <span class="o">...</span> <span class="c"># do something that requires SSL support</span>
</pre></div>
</div>
</div>
<div class="section" id="client-side-operation">
<h3>17.3.4.2. Client-side operation<a class="headerlink" href="ssl.html#client-side-operation" title="Permalink to this headline">¶</a></h3>
<p>This example connects to an SSL server, prints the server&#8217;s address and
certificate, sends some bytes, and reads part of the response:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">ssl</span><span class="o">,</span> <span class="nn">pprint</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>

<span class="c"># require a certificate from the server</span>
<span class="n">ssl_sock</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>
                           <span class="n">ca_certs</span><span class="o">=</span><span class="s">&quot;/etc/ca_certs_file&quot;</span><span class="p">,</span>
                           <span class="n">cert_reqs</span><span class="o">=</span><span class="n">ssl</span><span class="o">.</span><span class="n">CERT_REQUIRED</span><span class="p">)</span>

<span class="n">ssl_sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s">&#39;www.verisign.com&#39;</span><span class="p">,</span> <span class="mi">443</span><span class="p">))</span>

<span class="k">print</span> <span class="nb">repr</span><span class="p">(</span><span class="n">ssl_sock</span><span class="o">.</span><span class="n">getpeername</span><span class="p">())</span>
<span class="k">print</span> <span class="n">ssl_sock</span><span class="o">.</span><span class="n">cipher</span><span class="p">()</span>
<span class="k">print</span> <span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="n">ssl_sock</span><span class="o">.</span><span class="n">getpeercert</span><span class="p">())</span>

<span class="c"># Set a simple HTTP request -- use httplib in actual code.</span>
<span class="n">ssl_sock</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;&quot;&quot;GET / HTTP/1.0</span><span class="se">\r</span><span class="s"></span>
<span class="s">Host: www.verisign.com</span><span class="se">\r\n\r\n</span><span class="s">&quot;&quot;&quot;</span><span class="p">)</span>

<span class="c"># Read a chunk of data.  Will not necessarily</span>
<span class="c"># read all the data returned by the server.</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">ssl_sock</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="c"># note that closing the SSLSocket will also close the underlying socket</span>
<span class="n">ssl_sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>As of September 6, 2007, the certificate printed by this program looked like
this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">{</span><span class="s">&#39;notAfter&#39;</span><span class="p">:</span> <span class="s">&#39;May  8 23:59:59 2009 GMT&#39;</span><span class="p">,</span>
 <span class="s">&#39;subject&#39;</span><span class="p">:</span> <span class="p">(((</span><span class="s">&#39;serialNumber&#39;</span><span class="p">,</span> <span class="s">u&#39;2497886&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;1.3.6.1.4.1.311.60.2.1.3&#39;</span><span class="p">,</span> <span class="s">u&#39;US&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;1.3.6.1.4.1.311.60.2.1.2&#39;</span><span class="p">,</span> <span class="s">u&#39;Delaware&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;countryName&#39;</span><span class="p">,</span> <span class="s">u&#39;US&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;postalCode&#39;</span><span class="p">,</span> <span class="s">u&#39;94043&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;stateOrProvinceName&#39;</span><span class="p">,</span> <span class="s">u&#39;California&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;localityName&#39;</span><span class="p">,</span> <span class="s">u&#39;Mountain View&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;streetAddress&#39;</span><span class="p">,</span> <span class="s">u&#39;487 East Middlefield Road&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;organizationName&#39;</span><span class="p">,</span> <span class="s">u&#39;VeriSign, Inc.&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;organizationalUnitName&#39;</span><span class="p">,</span>
               <span class="s">u&#39;Production Security Services&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;organizationalUnitName&#39;</span><span class="p">,</span>
               <span class="s">u&#39;Terms of use at www.verisign.com/rpa (c)06&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;commonName&#39;</span><span class="p">,</span> <span class="s">u&#39;www.verisign.com&#39;</span><span class="p">),))}</span>
</pre></div>
</div>
<p>which is a fairly poorly-formed <tt class="docutils literal"><span class="pre">subject</span></tt> field.</p>
</div>
<div class="section" id="server-side-operation">
<h3>17.3.4.3. Server-side operation<a class="headerlink" href="ssl.html#server-side-operation" title="Permalink to this headline">¶</a></h3>
<p>For server operation, typically you&#8217;d need to have a server certificate, and
private key, each in a file.  You&#8217;d open a socket, bind it to a port, call
<tt class="xref py py-meth docutils literal"><span class="pre">listen()</span></tt> on it, then start waiting for clients to connect:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">ssl</span>

<span class="n">bindsocket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="n">bindsocket</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s">&#39;myaddr.mydomain.com&#39;</span><span class="p">,</span> <span class="mi">10023</span><span class="p">))</span>
<span class="n">bindsocket</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>When one did, you&#8217;d call <tt class="xref py py-meth docutils literal"><span class="pre">accept()</span></tt> on the socket to get the new socket from
the other end, and use <a class="reference internal" href="ssl.html#ssl.wrap_socket" title="ssl.wrap_socket"><tt class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></tt></a> to create a server-side SSL context
for it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">newsocket</span><span class="p">,</span> <span class="n">fromaddr</span> <span class="o">=</span> <span class="n">bindsocket</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
    <span class="n">connstream</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">newsocket</span><span class="p">,</span>
                                 <span class="n">server_side</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                 <span class="n">certfile</span><span class="o">=</span><span class="s">&quot;mycertfile&quot;</span><span class="p">,</span>
                                 <span class="n">keyfile</span><span class="o">=</span><span class="s">&quot;mykeyfile&quot;</span><span class="p">,</span>
                                 <span class="n">ssl_version</span><span class="o">=</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_TLSv1</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">deal_with_client</span><span class="p">(</span><span class="n">connstream</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">connstream</span><span class="o">.</span><span class="n">shutdown</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SHUT_RDWR</span><span class="p">)</span>
        <span class="n">connstream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>Then you&#8217;d read data from the <tt class="docutils literal"><span class="pre">connstream</span></tt> and do something with it till you
are finished with the client (or the client is finished with you):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">deal_with_client</span><span class="p">(</span><span class="n">connstream</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">connstream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="c"># null data means the client is finished with us</span>
    <span class="k">while</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">do_something</span><span class="p">(</span><span class="n">connstream</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
            <span class="c"># we&#39;ll assume do_something returns False</span>
            <span class="c"># when we&#39;re finished with client</span>
            <span class="k">break</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">connstream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="c"># finished with client</span>
</pre></div>
</div>
<p>And go back to listening for new client connections.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt>Class <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><tt class="xref py py-class docutils literal"><span class="pre">socket.socket</span></tt></a></dt>
<dd>Documentation of underlying <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><tt class="xref py py-mod docutils literal"><span class="pre">socket</span></tt></a> class</dd>
<dt><a class="reference external" href="http://www3.rad.com/networks/applications/secure/tls.htm">TLS (Transport Layer Security) and SSL (Secure Socket Layer)</a></dt>
<dd>Debby Koren</dd>
<dt><a class="reference external" href="http://www.ietf.org/rfc/rfc1422">RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: Certificate-Based Key Management</a></dt>
<dd>Steve Kent</dd>
<dt><a class="reference external" href="http://www.ietf.org/rfc/rfc1750">RFC 1750: Randomness Recommendations for Security</a></dt>
<dd>D. Eastlake et. al.</dd>
<dt><a class="reference external" href="http://www.ietf.org/rfc/rfc3280">RFC 3280: Internet X.509 Public Key Infrastructure Certificate and CRL Profile</a></dt>
<dd>Housley et. al.</dd>
</dl>
</div>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2015, Python Software Foundation.
    <br />
    The Python Software Foundation is a non-profit corporation.  
    <a href="http://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on May 28, 2015.
    <a href="../bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>

  </body>
</html>