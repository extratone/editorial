
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>mlab &mdash; Matplotlib 1.3.1 documentation</title>
    <link rel="stylesheet" href="../_static/pythonista.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.3.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Matplotlib 1.3.1 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="top" title="Matplotlib 1.3.1 documentation" href="../index.html" />
    <link rel="up" title="The Matplotlib API" href="index.html" />
    <link rel="next" title="path" href="path_api.html" />
    <link rel="prev" title="mathtext" href="mathtext_api.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="stylesheet" href="../_static/pythonista.css" type="text/css" />
    <meta name = "viewport" content = "width=device-width,initial-scale=1.0,user-scalable=no;">
    
    <script type="text/javascript">
        var getTextForSample = function(i) {
            codeBlock = document.getElementsByClassName('highlight-python')[i];
            return codeBlock.innerText;
        }
        
        var copySample = function (i) {
            window.location.href = '/__pythonista_copy__/' + encodeURI(getTextForSample(i));
        }
        
        var openSample = function (i) {
            window.location.href = '/__pythonista_open__/' + encodeURI(getTextForSample(i));
        }
        
        //Source: http://ejohn.org/blog/partial-functions-in-javascript/
        Function.prototype.partial = function() {
        	var fn = this,
        		args = Array.prototype.slice.call(arguments);
        	return function() {
        		var arg = 0;
        		for (var i = 0; i < args.length && arg < arguments.length; i++)
        		if (args[i] === undefined) args[i] = arguments[arg++];
        		return fn.apply(this, args);
        	};
        };
        
        window.onload=function() {
            //Add "Copy" and "Open in Editor" buttons for code samples:
            var inApp = navigator.userAgent.match(/AppleWebKit/i) != null && navigator.userAgent.match(/Safari/i) == null;
            if (inApp) {
                codeBlocks = document.getElementsByClassName('highlight-python');
                for (var i = 0; i < codeBlocks.length; i++) {
                    codeBlock = codeBlocks[i];
                    if (codeBlock.innerText.indexOf('>>>') == 0) {
                        //Don't add header for interactive sessions
                        continue;
                    }

                    var codeHeader = document.createElement('div');
                    codeHeader.className = 'pythonista-code-header';

                    var copyButton = document.createElement('button');
                    copyButton.className = 'pythonista-button';
                    copyButton.innerText = 'Copy';
                    copyButton.addEventListener('click', copySample.partial(i));
                    codeHeader.appendChild(copyButton);

                    var openButton = document.createElement('button');
                    openButton.className = 'pythonista-button';
                    openButton.innerText = 'Open in Editor';
                    openButton.addEventListener('click', openSample.partial(i));
                    codeHeader.appendChild(openButton);

                    codeBlock.parentElement.insertBefore(codeHeader, codeBlock);
                }
            }
        }
    </script>
    
 

  </head>
  <body ontouchstart="">
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="path_api.html" title="path"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="mathtext_api.html" title="mathtext"
             accesskey="P">previous</a> |</li>
        <li><a href="../../../pythonista.html"><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -4px; margin-right: 4px;"/></a></li>
        <li><a href="../index.html">Matplotlib 1.3.1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">The Matplotlib API</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="mlab">
<h1>mlab<a class="headerlink" href="mlab_api.html#mlab" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-matplotlib.mlab">
<span id="matplotlib-mlab"></span><h2><a class="reference internal" href="mlab_api.html#module-matplotlib.mlab" title="matplotlib.mlab"><tt class="xref py py-mod docutils literal"><span class="pre">matplotlib.mlab</span></tt></a><a class="headerlink" href="mlab_api.html#module-matplotlib.mlab" title="Permalink to this headline">¶</a></h2>
<p>Numerical python functions written for compatability with MATLAB
commands with the same names.</p>
<div class="section" id="matlab-compatible-functions">
<h3>MATLAB compatible functions<a class="headerlink" href="mlab_api.html#matlab-compatible-functions" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.cohere" title="matplotlib.mlab.cohere"><tt class="xref py py-func docutils literal"><span class="pre">cohere()</span></tt></a></dt>
<dd>Coherence (normalized cross spectral density)</dd>
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.csd" title="matplotlib.mlab.csd"><tt class="xref py py-func docutils literal"><span class="pre">csd()</span></tt></a></dt>
<dd>Cross spectral density uing Welch&#8217;s average periodogram</dd>
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><tt class="xref py py-func docutils literal"><span class="pre">detrend()</span></tt></a></dt>
<dd>Remove the mean or best fit line from an array</dd>
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.find" title="matplotlib.mlab.find"><tt class="xref py py-func docutils literal"><span class="pre">find()</span></tt></a></dt>
<dd><dl class="first last docutils">
<dt>Return the indices where some condition is true;</dt>
<dd>numpy.nonzero is similar but more general.</dd>
</dl>
</dd>
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.griddata" title="matplotlib.mlab.griddata"><tt class="xref py py-func docutils literal"><span class="pre">griddata()</span></tt></a></dt>
<dd><dl class="first last docutils">
<dt>interpolate irregularly distributed data to a</dt>
<dd>regular grid.</dd>
</dl>
</dd>
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.prctile" title="matplotlib.mlab.prctile"><tt class="xref py py-func docutils literal"><span class="pre">prctile()</span></tt></a></dt>
<dd>find the percentiles of a sequence</dd>
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.prepca" title="matplotlib.mlab.prepca"><tt class="xref py py-func docutils literal"><span class="pre">prepca()</span></tt></a></dt>
<dd>Principal Component Analysis</dd>
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><tt class="xref py py-func docutils literal"><span class="pre">psd()</span></tt></a></dt>
<dd>Power spectral density uing Welch&#8217;s average periodogram</dd>
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.rk4" title="matplotlib.mlab.rk4"><tt class="xref py py-func docutils literal"><span class="pre">rk4()</span></tt></a></dt>
<dd>A 4th order runge kutta integrator for 1D or ND systems</dd>
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><tt class="xref py py-func docutils literal"><span class="pre">specgram()</span></tt></a></dt>
<dd>Spectrogram (power spectral density over segments of time)</dd>
</dl>
</div>
<div class="section" id="miscellaneous-functions">
<h3>Miscellaneous functions<a class="headerlink" href="mlab_api.html#miscellaneous-functions" title="Permalink to this headline">¶</a></h3>
<p>Functions that don&#8217;t exist in MATLAB, but are useful anyway:</p>
<dl class="docutils">
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.cohere_pairs" title="matplotlib.mlab.cohere_pairs"><tt class="xref py py-meth docutils literal"><span class="pre">cohere_pairs()</span></tt></a></dt>
<dd>Coherence over all pairs.  This is not a MATLAB function, but we
compute coherence a lot in my lab, and we compute it for a lot of
pairs.  This function is optimized to do this efficiently by
caching the direct FFTs.</dd>
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.rk4" title="matplotlib.mlab.rk4"><tt class="xref py py-meth docutils literal"><span class="pre">rk4()</span></tt></a></dt>
<dd>A 4th order Runge-Kutta ODE integrator in case you ever find
yourself stranded without scipy (and the far superior
scipy.integrate tools)</dd>
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.contiguous_regions" title="matplotlib.mlab.contiguous_regions"><tt class="xref py py-meth docutils literal"><span class="pre">contiguous_regions()</span></tt></a></dt>
<dd>return the indices of the regions spanned by some logical mask</dd>
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.cross_from_below" title="matplotlib.mlab.cross_from_below"><tt class="xref py py-meth docutils literal"><span class="pre">cross_from_below()</span></tt></a></dt>
<dd>return the indices where a 1D array crosses a threshold from below</dd>
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.cross_from_above" title="matplotlib.mlab.cross_from_above"><tt class="xref py py-meth docutils literal"><span class="pre">cross_from_above()</span></tt></a></dt>
<dd>return the indices where a 1D array crosses a threshold from above</dd>
</dl>
</div>
<div class="section" id="record-array-helper-functions">
<h3>record array helper functions<a class="headerlink" href="mlab_api.html#record-array-helper-functions" title="Permalink to this headline">¶</a></h3>
<p>A collection of helper methods for numpyrecord arrays</p>
<blockquote id="htmlonly">
<div>See <a class="reference internal" href="../examples/misc/index.html#misc-examples-index"><em>misc Examples</em></a></div></blockquote>
<dl class="docutils">
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.rec2txt" title="matplotlib.mlab.rec2txt"><tt class="xref py py-meth docutils literal"><span class="pre">rec2txt()</span></tt></a></dt>
<dd>pretty print a record array</dd>
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.rec2csv" title="matplotlib.mlab.rec2csv"><tt class="xref py py-meth docutils literal"><span class="pre">rec2csv()</span></tt></a></dt>
<dd>store record array in CSV file</dd>
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.csv2rec" title="matplotlib.mlab.csv2rec"><tt class="xref py py-meth docutils literal"><span class="pre">csv2rec()</span></tt></a></dt>
<dd>import record array from CSV file with type inspection</dd>
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.rec_append_fields" title="matplotlib.mlab.rec_append_fields"><tt class="xref py py-meth docutils literal"><span class="pre">rec_append_fields()</span></tt></a></dt>
<dd>adds  field(s)/array(s) to record array</dd>
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.rec_drop_fields" title="matplotlib.mlab.rec_drop_fields"><tt class="xref py py-meth docutils literal"><span class="pre">rec_drop_fields()</span></tt></a></dt>
<dd>drop fields from record array</dd>
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.rec_join" title="matplotlib.mlab.rec_join"><tt class="xref py py-meth docutils literal"><span class="pre">rec_join()</span></tt></a></dt>
<dd>join two record arrays on sequence of fields</dd>
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.recs_join" title="matplotlib.mlab.recs_join"><tt class="xref py py-meth docutils literal"><span class="pre">recs_join()</span></tt></a></dt>
<dd>a simple join of multiple recarrays using a single column as a key</dd>
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.rec_groupby" title="matplotlib.mlab.rec_groupby"><tt class="xref py py-meth docutils literal"><span class="pre">rec_groupby()</span></tt></a></dt>
<dd>summarize data by groups (similar to SQL GROUP BY)</dd>
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.rec_summarize" title="matplotlib.mlab.rec_summarize"><tt class="xref py py-meth docutils literal"><span class="pre">rec_summarize()</span></tt></a></dt>
<dd>helper code to filter rec array fields into new fields</dd>
</dl>
<p>For the rec viewer functions(e rec2csv), there are a bunch of Format
objects you can pass into the functions that will do things like color
negative values red, set percent formatting and scaling, etc.</p>
<p>Example usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">r</span> <span class="o">=</span> <span class="n">csv2rec</span><span class="p">(</span><span class="s">&#39;somefile.csv&#39;</span><span class="p">,</span> <span class="n">checkrows</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="n">formatd</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">FormatFloat</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
    <span class="n">change</span> <span class="o">=</span> <span class="n">FormatPercent</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
    <span class="n">cost</span>   <span class="o">=</span> <span class="n">FormatThousands</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
    <span class="p">)</span>


<span class="n">rec2excel</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="s">&#39;test.xls&#39;</span><span class="p">,</span> <span class="n">formatd</span><span class="o">=</span><span class="n">formatd</span><span class="p">)</span>
<span class="n">rec2csv</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="s">&#39;test.csv&#39;</span><span class="p">,</span> <span class="n">formatd</span><span class="o">=</span><span class="n">formatd</span><span class="p">)</span>
<span class="n">scroll</span> <span class="o">=</span> <span class="n">rec2gtk</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">formatd</span><span class="o">=</span><span class="n">formatd</span><span class="p">)</span>

<span class="n">win</span> <span class="o">=</span> <span class="n">gtk</span><span class="o">.</span><span class="n">Window</span><span class="p">()</span>
<span class="n">win</span><span class="o">.</span><span class="n">set_size_request</span><span class="p">(</span><span class="mi">600</span><span class="p">,</span><span class="mi">800</span><span class="p">)</span>
<span class="n">win</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">scroll</span><span class="p">)</span>
<span class="n">win</span><span class="o">.</span><span class="n">show_all</span><span class="p">()</span>
<span class="n">gtk</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="deprecated-functions">
<h3>Deprecated functions<a class="headerlink" href="mlab_api.html#deprecated-functions" title="Permalink to this headline">¶</a></h3>
<p>The following are deprecated; please import directly from numpy (with
care&#8211;function signatures may differ):</p>
<dl class="docutils">
<dt><tt class="xref py py-meth docutils literal"><span class="pre">load()</span></tt></dt>
<dd>load ASCII file - use numpy.loadtxt</dd>
<dt><tt class="xref py py-meth docutils literal"><span class="pre">save()</span></tt></dt>
<dd>save ASCII file - use numpy.savetxt</dd>
</dl>
<dl class="class">
<dt id="matplotlib.mlab.FIFOBuffer">
<em class="property">class </em><tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">FIFOBuffer</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FIFOBuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>A FIFO queue to hold incoming <em>x</em>, <em>y</em> data in a rotating buffer
using numpy arrays under the hood.  It is assumed that you will
call asarrays much less frequently than you add data to the queue
&#8211; otherwise another data structure will be faster.</p>
<p>This can be used to support plots where data is added from a real
time feed and the plot object wants to grab data from the buffer
and plot it to screen less freqeuently than the incoming.</p>
<p>If you set the <em>dataLim</em> attr to
<tt class="xref py py-class docutils literal"><span class="pre">BBox</span></tt> (eg
<tt class="xref py py-attr docutils literal"><span class="pre">matplotlib.Axes.dataLim</span></tt>), the <em>dataLim</em> will be updated as
new data come in.</p>
<p>TODO: add a grow method that will extend nmax</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">mlab seems like the wrong place for this class.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 1.3: </span>The FIFOBuffer class was deprecated in version 1.3.</p>
</div>
<p>Buffer up to <em>nmax</em> points.</p>
<dl class="method">
<dt id="matplotlib.mlab.FIFOBuffer.add">
<tt class="descname">add</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FIFOBuffer.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add scalar <em>x</em> and <em>y</em> to the queue.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.mlab.FIFOBuffer.asarrays">
<tt class="descname">asarrays</tt><big>(</big><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FIFOBuffer.asarrays" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <em>x</em> and <em>y</em> as arrays; their length will be the len of
data added or <em>nmax</em>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.mlab.FIFOBuffer.last">
<tt class="descname">last</tt><big>(</big><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FIFOBuffer.last" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the last <em>x</em>, <em>y</em> or <em>None</em>.  <em>None</em> if no data set.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.mlab.FIFOBuffer.register">
<tt class="descname">register</tt><big>(</big><em>func</em>, <em>N</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FIFOBuffer.register" title="Permalink to this definition">¶</a></dt>
<dd><p>Call <em>func</em> every time <em>N</em> events are passed; <em>func</em> signature
is <tt class="docutils literal"><span class="pre">func(fifo)</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.mlab.FIFOBuffer.update_datalim_to_current">
<tt class="descname">update_datalim_to_current</tt><big>(</big><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FIFOBuffer.update_datalim_to_current" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the <em>datalim</em> in the current data in the fifo.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.mlab.FormatBool">
<em class="property">class </em><tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">FormatBool</tt><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FormatBool" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mlab_api.html#matplotlib.mlab.FormatObj" title="matplotlib.mlab.FormatObj"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.mlab.FormatObj</span></tt></a></p>
<dl class="method">
<dt id="matplotlib.mlab.FormatBool.fromstr">
<tt class="descname">fromstr</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FormatBool.fromstr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.mlab.FormatBool.toval">
<tt class="descname">toval</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FormatBool.toval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.mlab.FormatDate">
<em class="property">class </em><tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">FormatDate</tt><big>(</big><em>fmt</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FormatDate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mlab_api.html#matplotlib.mlab.FormatObj" title="matplotlib.mlab.FormatObj"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.mlab.FormatObj</span></tt></a></p>
<dl class="method">
<dt id="matplotlib.mlab.FormatDate.fromstr">
<tt class="descname">fromstr</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FormatDate.fromstr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.mlab.FormatDate.toval">
<tt class="descname">toval</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FormatDate.toval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.mlab.FormatDatetime">
<em class="property">class </em><tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">FormatDatetime</tt><big>(</big><em>fmt='%Y-%m-%d %H:%M:%S'</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FormatDatetime" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mlab_api.html#matplotlib.mlab.FormatDate" title="matplotlib.mlab.FormatDate"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.mlab.FormatDate</span></tt></a></p>
<dl class="method">
<dt id="matplotlib.mlab.FormatDatetime.fromstr">
<tt class="descname">fromstr</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FormatDatetime.fromstr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.mlab.FormatFloat">
<em class="property">class </em><tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">FormatFloat</tt><big>(</big><em>precision=4</em>, <em>scale=1.0</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FormatFloat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mlab_api.html#matplotlib.mlab.FormatFormatStr" title="matplotlib.mlab.FormatFormatStr"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.mlab.FormatFormatStr</span></tt></a></p>
<dl class="method">
<dt id="matplotlib.mlab.FormatFloat.fromstr">
<tt class="descname">fromstr</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FormatFloat.fromstr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.mlab.FormatFloat.toval">
<tt class="descname">toval</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FormatFloat.toval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.mlab.FormatFormatStr">
<em class="property">class </em><tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">FormatFormatStr</tt><big>(</big><em>fmt</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FormatFormatStr" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mlab_api.html#matplotlib.mlab.FormatObj" title="matplotlib.mlab.FormatObj"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.mlab.FormatObj</span></tt></a></p>
<dl class="method">
<dt id="matplotlib.mlab.FormatFormatStr.tostr">
<tt class="descname">tostr</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FormatFormatStr.tostr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.mlab.FormatInt">
<em class="property">class </em><tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">FormatInt</tt><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FormatInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mlab_api.html#matplotlib.mlab.FormatObj" title="matplotlib.mlab.FormatObj"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.mlab.FormatObj</span></tt></a></p>
<dl class="method">
<dt id="matplotlib.mlab.FormatInt.fromstr">
<tt class="descname">fromstr</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FormatInt.fromstr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.mlab.FormatInt.tostr">
<tt class="descname">tostr</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FormatInt.tostr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.mlab.FormatInt.toval">
<tt class="descname">toval</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FormatInt.toval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.mlab.FormatMillions">
<em class="property">class </em><tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">FormatMillions</tt><big>(</big><em>precision=4</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FormatMillions" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mlab_api.html#matplotlib.mlab.FormatFloat" title="matplotlib.mlab.FormatFloat"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.mlab.FormatFloat</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="matplotlib.mlab.FormatObj">
<em class="property">class </em><tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">FormatObj</tt><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FormatObj" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="matplotlib.mlab.FormatObj.fromstr">
<tt class="descname">fromstr</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FormatObj.fromstr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.mlab.FormatObj.tostr">
<tt class="descname">tostr</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FormatObj.tostr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.mlab.FormatObj.toval">
<tt class="descname">toval</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FormatObj.toval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.mlab.FormatPercent">
<em class="property">class </em><tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">FormatPercent</tt><big>(</big><em>precision=4</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FormatPercent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mlab_api.html#matplotlib.mlab.FormatFloat" title="matplotlib.mlab.FormatFloat"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.mlab.FormatFloat</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="matplotlib.mlab.FormatString">
<em class="property">class </em><tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">FormatString</tt><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FormatString" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mlab_api.html#matplotlib.mlab.FormatObj" title="matplotlib.mlab.FormatObj"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.mlab.FormatObj</span></tt></a></p>
<dl class="method">
<dt id="matplotlib.mlab.FormatString.tostr">
<tt class="descname">tostr</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FormatString.tostr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.mlab.FormatThousands">
<em class="property">class </em><tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">FormatThousands</tt><big>(</big><em>precision=4</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.FormatThousands" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mlab_api.html#matplotlib.mlab.FormatFloat" title="matplotlib.mlab.FormatFloat"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.mlab.FormatFloat</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="matplotlib.mlab.PCA">
<em class="property">class </em><tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">PCA</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.PCA" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the SVD of a and store data for PCA.  Use project to
project the data onto a reduced set of dimensions</p>
<p>Inputs:</p>
<blockquote>
<div><em>a</em>: a numobservations x numdims array</div></blockquote>
<p>Attrs:</p>
<blockquote>
<div><p><em>a</em> a centered unit sigma version of input a</p>
<p><em>numrows</em>, <em>numcols</em>: the dimensions of a</p>
<p><em>mu</em> : a numdims array of means of a</p>
<p><em>sigma</em> : a numdims array of atandard deviation of a</p>
<p><em>fracs</em> : the proportion of variance of each of the principal components</p>
<p><em>Wt</em> : the weight vector for projecting a numdims point or array into PCA space</p>
<p><em>Y</em> : a projected into PCA space</p>
</div></blockquote>
<p>The factor loadings are in the Wt factor, ie the factor
loadings for the 1st principal component are given by Wt[0]</p>
<dl class="method">
<dt id="matplotlib.mlab.PCA.center">
<tt class="descname">center</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.PCA.center" title="Permalink to this definition">¶</a></dt>
<dd><p>center the data using the mean and sigma from training set a</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.mlab.PCA.project">
<tt class="descname">project</tt><big>(</big><em>x</em>, <em>minfrac=0.0</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.PCA.project" title="Permalink to this definition">¶</a></dt>
<dd><p>project x onto the principle axes, dropping any axes where fraction of variance&lt;minfrac</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.amap">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">amap</tt><big>(</big><em>function</em>, <em>sequence</em><span class="optional">[</span>, <em>sequence</em>, <em>...</em><span class="optional">]</span><big>)</big> &rarr; array.<a class="headerlink" href="mlab_api.html#matplotlib.mlab.amap" title="Permalink to this definition">¶</a></dt>
<dd><p>Works like <tt class="xref py py-func docutils literal"><span class="pre">map()</span></tt>, but it returns an array.  This is just a
convenient shorthand for <tt class="docutils literal"><span class="pre">numpy.array(map(...))</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.base_repr">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">base_repr</tt><big>(</big><em>number</em>, <em>base=2</em>, <em>padding=0</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.base_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the representation of a <em>number</em> in any given <em>base</em>.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.binary_repr">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">binary_repr</tt><big>(</big><em>number</em>, <em>max_length=1025</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.binary_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the binary representation of the input <em>number</em> as a
string.</p>
<p>This is more efficient than using <a class="reference internal" href="mlab_api.html#matplotlib.mlab.base_repr" title="matplotlib.mlab.base_repr"><tt class="xref py py-func docutils literal"><span class="pre">base_repr()</span></tt></a> with base 2.</p>
<p>Increase the value of max_length for very large numbers. Note that
on 32-bit machines, 2**1023 is the largest integer power of 2
which can be converted to a Python float.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.bivariate_normal">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">bivariate_normal</tt><big>(</big><em>X</em>, <em>Y</em>, <em>sigmax=1.0</em>, <em>sigmay=1.0</em>, <em>mux=0.0</em>, <em>muy=0.0</em>, <em>sigmaxy=0.0</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.bivariate_normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Bivariate Gaussian distribution for equal shape <em>X</em>, <em>Y</em>.</p>
<p>See <a class="reference external" href="http://mathworld.wolfram.com/BivariateNormalDistribution.html">bivariate normal</a>
at mathworld.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.center_matrix">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">center_matrix</tt><big>(</big><em>M</em>, <em>dim=0</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.center_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix <em>M</em> with each row having zero mean and unit std.</p>
<p>If <em>dim</em> = 1 operate on columns instead of rows.  (<em>dim</em> is
opposite to the numpy axis kwarg.)</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.cohere">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">cohere</tt><big>(</big><em>x</em>, <em>y</em>, <em>NFFT=256</em>, <em>Fs=2</em>, <em>detrend=&lt;function detrend_none at 0x10a77d5f0&gt;</em>, <em>window=&lt;function window_hanning at 0x10a7646e0&gt;</em>, <em>noverlap=0</em>, <em>pad_to=None</em>, <em>sides='default'</em>, <em>scale_by_freq=None</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.cohere" title="Permalink to this definition">¶</a></dt>
<dd><p>The coherence between <em>x</em> and <em>y</em>.  Coherence is the normalized
cross spectral density:</p>
<img src="../_images/mathmpl/math-58775d54bf.png" class="center" /><dl class="docutils">
<dt><em>x</em>, <em>y</em></dt>
<dd>Array or sequence containing the data</dd>
</dl>
<p>Keyword arguments:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>NFFT</em>: integer</dt>
<dd>The number of data points used in each block for the FFT.
Must be even; a power 2 is most efficient.  The default value is 256.
This should <em>NOT</em> be used to get zero padding, or the scaling of the
result will be incorrect. Use <em>pad_to</em> for this instead.</dd>
<dt><em>Fs</em>: scalar</dt>
<dd>The sampling frequency (samples per time unit).  It is used
to calculate the Fourier frequencies, freqs, in cycles per time
unit. The default value is 2.</dd>
<dt><em>detrend</em>: callable</dt>
<dd>The function applied to each segment before fft-ing,
designed to remove the mean or linear trend.  Unlike in
MATLAB, where the <em>detrend</em> parameter is a vector, in
matplotlib is it a function.  The <tt class="xref py py-mod docutils literal"><span class="pre">pylab</span></tt>
module defines <tt class="xref py py-func docutils literal"><span class="pre">detrend_none()</span></tt>,
<tt class="xref py py-func docutils literal"><span class="pre">detrend_mean()</span></tt>, and
<tt class="xref py py-func docutils literal"><span class="pre">detrend_linear()</span></tt>, but you can use
a custom function as well.</dd>
<dt><em>window</em>: callable or ndarray</dt>
<dd>A function or a vector of length <em>NFFT</em>. To create window
vectors see <a class="reference internal" href="mlab_api.html#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><tt class="xref py py-func docutils literal"><span class="pre">window_hanning()</span></tt></a>, <a class="reference internal" href="mlab_api.html#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><tt class="xref py py-func docutils literal"><span class="pre">window_none()</span></tt></a>,
<tt class="xref py py-func docutils literal"><span class="pre">numpy.blackman()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">numpy.hamming()</span></tt>,
<tt class="xref py py-func docutils literal"><span class="pre">numpy.bartlett()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">scipy.signal()</span></tt>,
<tt class="xref py py-func docutils literal"><span class="pre">scipy.signal.get_window()</span></tt>, etc. The default is
<a class="reference internal" href="mlab_api.html#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><tt class="xref py py-func docutils literal"><span class="pre">window_hanning()</span></tt></a>.  If a function is passed as the
argument, it must take a data segment as an argument and
return the windowed version of the segment.</dd>
<dt><em>pad_to</em>: integer</dt>
<dd>The number of points to which the data segment is padded when
performing the FFT.  This can be different from <em>NFFT</em>, which
specifies the number of data points used.  While not increasing
the actual resolution of the psd (the minimum distance between
resolvable peaks), this can give more points in the plot,
allowing for more detail. This corresponds to the <em>n</em> parameter
in the call to fft(). The default is None, which sets <em>pad_to</em>
equal to <em>NFFT</em></dd>
<dt><em>sides</em>: [ &#8216;default&#8217; | &#8216;onesided&#8217; | &#8216;twosided&#8217; ]</dt>
<dd>Specifies which sides of the PSD to return.  Default gives the
default behavior, which returns one-sided for real data and both
for complex data.  &#8216;onesided&#8217; forces the return of a one-sided PSD,
while &#8216;twosided&#8217; forces two-sided.</dd>
<dt><em>scale_by_freq</em>: boolean</dt>
<dd>Specifies whether the resulting density values should be scaled
by the scaling frequency, which gives density in units of Hz^-1.
This allows for integration over the returned frequency values.
The default is True for MATLAB compatibility.</dd>
<dt><em>noverlap</em>: integer</dt>
<dd>The number of points of overlap between blocks.  The default value
is 0 (no overlap).</dd>
</dl>
</div></blockquote>
<p>The return value is the tuple (<em>Cxy</em>, <em>f</em>), where <em>f</em> are the
frequencies of the coherence vector. For cohere, scaling the
individual densities by the sampling frequency has no effect,
since the factors cancel out.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><tt class="xref py py-func docutils literal"><span class="pre">psd()</span></tt></a> and <a class="reference internal" href="mlab_api.html#matplotlib.mlab.csd" title="matplotlib.mlab.csd"><tt class="xref py py-func docutils literal"><span class="pre">csd()</span></tt></a></dt>
<dd>For information about the methods used to compute
<img src="../_images/mathmpl/math-0005c3a5e5.png" style="position: relative; bottom: -10px"/>, <img src="../_images/mathmpl/math-f6d65b7f49.png" style="position: relative; bottom: -7px"/> and <img src="../_images/mathmpl/math-0938c51d1a.png" style="position: relative; bottom: -10px"/>.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.cohere_pairs">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">cohere_pairs</tt><big>(</big><em>X</em>, <em>ij</em>, <em>NFFT=256</em>, <em>Fs=2</em>, <em>detrend=&lt;function detrend_none at 0x10a77d5f0&gt;</em>, <em>window=&lt;function window_hanning at 0x10a7646e0&gt;</em>, <em>noverlap=0</em>, <em>preferSpeedOverMemory=True</em>, <em>progressCallback=&lt;function donothing_callback at 0x10a77e488&gt;</em>, <em>returnPxx=False</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.cohere_pairs" title="Permalink to this definition">¶</a></dt>
<dd><p>Call signature:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Cxy</span><span class="p">,</span> <span class="n">Phase</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">cohere_pairs</span><span class="p">(</span> <span class="n">X</span><span class="p">,</span> <span class="n">ij</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>Compute the coherence and phase for all pairs <em>ij</em>, in <em>X</em>.</p>
<p><em>X</em> is a <em>numSamples</em> * <em>numCols</em> array</p>
<p><em>ij</em> is a list of tuples.  Each tuple is a pair of indexes into
the columns of X for which you want to compute coherence.  For
example, if <em>X</em> has 64 columns, and you want to compute all
nonredundant pairs, define <em>ij</em> as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ij</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">64</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">64</span><span class="p">):</span>
        <span class="n">ij</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p><em>preferSpeedOverMemory</em> is an optional bool. Defaults to true. If
False, limits the caching by only making one, rather than two,
complex cache arrays. This is useful if memory becomes critical.
Even when <em>preferSpeedOverMemory</em> is False, <a class="reference internal" href="mlab_api.html#matplotlib.mlab.cohere_pairs" title="matplotlib.mlab.cohere_pairs"><tt class="xref py py-func docutils literal"><span class="pre">cohere_pairs()</span></tt></a>
will still give significant performace gains over calling
<a class="reference internal" href="mlab_api.html#matplotlib.mlab.cohere" title="matplotlib.mlab.cohere"><tt class="xref py py-func docutils literal"><span class="pre">cohere()</span></tt></a> for each pair, and will use subtantially less
memory than if <em>preferSpeedOverMemory</em> is True.  In my tests with
a 43000,64 array over all nonredundant pairs,
<em>preferSpeedOverMemory</em> = True delivered a 33% performance boost
on a 1.7GHZ Athlon with 512MB RAM compared with
<em>preferSpeedOverMemory</em> = False.  But both solutions were more
than 10x faster than naively crunching all possible pairs through
<a class="reference internal" href="mlab_api.html#matplotlib.mlab.cohere" title="matplotlib.mlab.cohere"><tt class="xref py py-func docutils literal"><span class="pre">cohere()</span></tt></a>.</p>
<p>Returns:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">Cxy</span><span class="p">,</span> <span class="n">Phase</span><span class="p">,</span> <span class="n">freqs</span><span class="p">)</span>
</pre></div>
</div>
<p>where:</p>
<blockquote>
<div><ul>
<li><p class="first"><em>Cxy</em>: dictionary of (<em>i</em>, <em>j</em>) tuples -&gt; coherence vector for
that pair.  I.e., <tt class="docutils literal"><span class="pre">Cxy[(i,j)</span> <span class="pre">=</span> <span class="pre">cohere(X[:,i],</span> <span class="pre">X[:,j])</span></tt>.
Number of dictionary keys is <tt class="docutils literal"><span class="pre">len(ij)</span></tt>.</p>
</li>
<li><p class="first"><em>Phase</em>: dictionary of phases of the cross spectral density at
each frequency for each pair.  Keys are (<em>i</em>, <em>j</em>).</p>
</li>
<li><dl class="first docutils">
<dt><em>freqs</em>: vector of frequencies, equal in length to either the</dt>
<dd><p class="first last">coherence or phase vectors for any (<em>i</em>, <em>j</em>) key.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>e.g., to make a coherence Bode plot:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">subplot</span><span class="p">(</span><span class="mi">211</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">Cxy</span><span class="p">[(</span><span class="mi">12</span><span class="p">,</span><span class="mi">19</span><span class="p">)])</span>
<span class="n">subplot</span><span class="p">(</span><span class="mi">212</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">Phase</span><span class="p">[(</span><span class="mi">12</span><span class="p">,</span><span class="mi">19</span><span class="p">)])</span>
</pre></div>
</div>
<p>For a large number of pairs, <a class="reference internal" href="mlab_api.html#matplotlib.mlab.cohere_pairs" title="matplotlib.mlab.cohere_pairs"><tt class="xref py py-func docutils literal"><span class="pre">cohere_pairs()</span></tt></a> can be much more
efficient than just calling <a class="reference internal" href="mlab_api.html#matplotlib.mlab.cohere" title="matplotlib.mlab.cohere"><tt class="xref py py-func docutils literal"><span class="pre">cohere()</span></tt></a> for each pair, because
it caches most of the intensive computations.  If <img src="../_images/mathmpl/math-1922d1ceaa.png" style="position: relative; bottom: -3px"/> is the
number of pairs, this function is <img src="../_images/mathmpl/math-98c8089378.png" style="position: relative; bottom: -8px"/> for most of the
heavy lifting, whereas calling cohere for each pair is
<img src="../_images/mathmpl/math-83ff203e39.png" style="position: relative; bottom: -8px"/>.  However, because of the caching, it is also more
memory intensive, making 2 additional complex arrays with
approximately the same number of elements as <em>X</em>.</p>
<p>See <tt class="file docutils literal"><span class="pre">test/cohere_pairs_test.py</span></tt> in the src tree for an
example script that shows that this <a class="reference internal" href="mlab_api.html#matplotlib.mlab.cohere_pairs" title="matplotlib.mlab.cohere_pairs"><tt class="xref py py-func docutils literal"><span class="pre">cohere_pairs()</span></tt></a> and
<a class="reference internal" href="mlab_api.html#matplotlib.mlab.cohere" title="matplotlib.mlab.cohere"><tt class="xref py py-func docutils literal"><span class="pre">cohere()</span></tt></a> give the same results for a given pair.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><tt class="xref py py-func docutils literal"><span class="pre">psd()</span></tt></a></dt>
<dd>For information about the methods used to compute
<img src="../_images/mathmpl/math-0005c3a5e5.png" style="position: relative; bottom: -10px"/>, <img src="../_images/mathmpl/math-f6d65b7f49.png" style="position: relative; bottom: -7px"/> and <img src="../_images/mathmpl/math-0938c51d1a.png" style="position: relative; bottom: -10px"/>.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.contiguous_regions">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">contiguous_regions</tt><big>(</big><em>mask</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.contiguous_regions" title="Permalink to this definition">¶</a></dt>
<dd><p>return a list of (ind0, ind1) such that mask[ind0:ind1].all() is
True and we cover all such regions</p>
<p>TODO: this is a pure python implementation which probably has a much faster numpy impl</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.cross_from_above">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">cross_from_above</tt><big>(</big><em>x</em>, <em>threshold</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.cross_from_above" title="Permalink to this definition">¶</a></dt>
<dd><p>return the indices into <em>x</em> where <em>x</em> crosses some threshold from
below, eg the i&#8217;s where:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">threshold</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">threshold</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mlab_api.html#matplotlib.mlab.cross_from_below" title="matplotlib.mlab.cross_from_below"><tt class="xref py py-func docutils literal"><span class="pre">cross_from_below()</span></tt></a> and <a class="reference internal" href="mlab_api.html#matplotlib.mlab.contiguous_regions" title="matplotlib.mlab.contiguous_regions"><tt class="xref py py-func docutils literal"><span class="pre">contiguous_regions()</span></tt></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.cross_from_below">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">cross_from_below</tt><big>(</big><em>x</em>, <em>threshold</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.cross_from_below" title="Permalink to this definition">¶</a></dt>
<dd><p>return the indices into <em>x</em> where <em>x</em> crosses some threshold from
below, eg the i&#8217;s where:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">threshold</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">threshold</span>
</pre></div>
</div>
<p>Example code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="s">&#39;-o&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>

<span class="n">ind</span> <span class="o">=</span> <span class="n">cross_from_below</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">ind</span> <span class="o">=</span> <span class="n">cross_from_above</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mlab_api.html#matplotlib.mlab.cross_from_above" title="matplotlib.mlab.cross_from_above"><tt class="xref py py-func docutils literal"><span class="pre">cross_from_above()</span></tt></a> and <a class="reference internal" href="mlab_api.html#matplotlib.mlab.contiguous_regions" title="matplotlib.mlab.contiguous_regions"><tt class="xref py py-func docutils literal"><span class="pre">contiguous_regions()</span></tt></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.csd">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">csd</tt><big>(</big><em>x</em>, <em>y</em>, <em>NFFT=256</em>, <em>Fs=2</em>, <em>detrend=&lt;function detrend_none at 0x10a77d5f0&gt;</em>, <em>window=&lt;function window_hanning at 0x10a7646e0&gt;</em>, <em>noverlap=0</em>, <em>pad_to=None</em>, <em>sides='default'</em>, <em>scale_by_freq=None</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.csd" title="Permalink to this definition">¶</a></dt>
<dd><p>The cross power spectral density by Welch&#8217;s average periodogram
method.  The vectors <em>x</em> and <em>y</em> are divided into <em>NFFT</em> length
blocks.  Each block is detrended by the function <em>detrend</em> and
windowed by the function <em>window</em>.  <em>noverlap</em> gives the length
of the overlap between blocks.  The product of the direct FFTs
of <em>x</em> and <em>y</em> are averaged over each segment to compute <em>Pxy</em>,
with a scaling to correct for power loss due to windowing.</p>
<p>If len(<em>x</em>) &lt; <em>NFFT</em> or len(<em>y</em>) &lt; <em>NFFT</em>, they will be zero
padded to <em>NFFT</em>.</p>
<dl class="docutils">
<dt><em>x</em>, <em>y</em></dt>
<dd>Array or sequence containing the data</dd>
</dl>
<p>Keyword arguments:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>NFFT</em>: integer</dt>
<dd>The number of data points used in each block for the FFT.
Must be even; a power 2 is most efficient.  The default value is 256.
This should <em>NOT</em> be used to get zero padding, or the scaling of the
result will be incorrect. Use <em>pad_to</em> for this instead.</dd>
<dt><em>Fs</em>: scalar</dt>
<dd>The sampling frequency (samples per time unit).  It is used
to calculate the Fourier frequencies, freqs, in cycles per time
unit. The default value is 2.</dd>
<dt><em>detrend</em>: callable</dt>
<dd>The function applied to each segment before fft-ing,
designed to remove the mean or linear trend.  Unlike in
MATLAB, where the <em>detrend</em> parameter is a vector, in
matplotlib is it a function.  The <tt class="xref py py-mod docutils literal"><span class="pre">pylab</span></tt>
module defines <tt class="xref py py-func docutils literal"><span class="pre">detrend_none()</span></tt>,
<tt class="xref py py-func docutils literal"><span class="pre">detrend_mean()</span></tt>, and
<tt class="xref py py-func docutils literal"><span class="pre">detrend_linear()</span></tt>, but you can use
a custom function as well.</dd>
<dt><em>window</em>: callable or ndarray</dt>
<dd>A function or a vector of length <em>NFFT</em>. To create window
vectors see <a class="reference internal" href="mlab_api.html#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><tt class="xref py py-func docutils literal"><span class="pre">window_hanning()</span></tt></a>, <a class="reference internal" href="mlab_api.html#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><tt class="xref py py-func docutils literal"><span class="pre">window_none()</span></tt></a>,
<tt class="xref py py-func docutils literal"><span class="pre">numpy.blackman()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">numpy.hamming()</span></tt>,
<tt class="xref py py-func docutils literal"><span class="pre">numpy.bartlett()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">scipy.signal()</span></tt>,
<tt class="xref py py-func docutils literal"><span class="pre">scipy.signal.get_window()</span></tt>, etc. The default is
<a class="reference internal" href="mlab_api.html#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><tt class="xref py py-func docutils literal"><span class="pre">window_hanning()</span></tt></a>.  If a function is passed as the
argument, it must take a data segment as an argument and
return the windowed version of the segment.</dd>
<dt><em>pad_to</em>: integer</dt>
<dd>The number of points to which the data segment is padded when
performing the FFT.  This can be different from <em>NFFT</em>, which
specifies the number of data points used.  While not increasing
the actual resolution of the psd (the minimum distance between
resolvable peaks), this can give more points in the plot,
allowing for more detail. This corresponds to the <em>n</em> parameter
in the call to fft(). The default is None, which sets <em>pad_to</em>
equal to <em>NFFT</em></dd>
<dt><em>sides</em>: [ &#8216;default&#8217; | &#8216;onesided&#8217; | &#8216;twosided&#8217; ]</dt>
<dd>Specifies which sides of the PSD to return.  Default gives the
default behavior, which returns one-sided for real data and both
for complex data.  &#8216;onesided&#8217; forces the return of a one-sided PSD,
while &#8216;twosided&#8217; forces two-sided.</dd>
<dt><em>scale_by_freq</em>: boolean</dt>
<dd>Specifies whether the resulting density values should be scaled
by the scaling frequency, which gives density in units of Hz^-1.
This allows for integration over the returned frequency values.
The default is True for MATLAB compatibility.</dd>
<dt><em>noverlap</em>: integer</dt>
<dd>The number of points of overlap between blocks.  The default value
is 0 (no overlap).</dd>
</dl>
</div></blockquote>
<p>Returns the tuple (<em>Pxy</em>, <em>freqs</em>).</p>
<dl class="docutils">
<dt>Refs:</dt>
<dd>Bendat &amp; Piersol &#8211; Random Data: Analysis and Measurement
Procedures, John Wiley &amp; Sons (1986)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.csv2rec">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">csv2rec</tt><big>(</big><em>fname</em>, <em>comments='#'</em>, <em>skiprows=0</em>, <em>checkrows=0</em>, <em>delimiter='</em>, <em>'</em>, <em>converterd=None</em>, <em>names=None</em>, <em>missing=''</em>, <em>missingd=None</em>, <em>use_mrecords=False</em>, <em>dayfirst=False</em>, <em>yearfirst=False</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.csv2rec" title="Permalink to this definition">¶</a></dt>
<dd><p>Load data from comma/space/tab delimited file in <em>fname</em> into a
numpy record array and return the record array.</p>
<p>If <em>names</em> is <em>None</em>, a header row is required to automatically
assign the recarray names.  The headers will be lower cased,
spaces will be converted to underscores, and illegal attribute
name characters removed.  If <em>names</em> is not <em>None</em>, it is a
sequence of names to use for the column names.  In this case, it
is assumed there is no header row.</p>
<ul>
<li><p class="first"><em>fname</em>: can be a filename or a file handle.  Support for gzipped
files is automatic, if the filename ends in &#8216;.gz&#8217;</p>
</li>
<li><p class="first"><em>comments</em>: the character used to indicate the start of a comment
in the file, or <em>None</em> to switch off the removal of comments</p>
</li>
<li><p class="first"><em>skiprows</em>: is the number of rows from the top to skip</p>
</li>
<li><p class="first"><em>checkrows</em>: is the number of rows to check to validate the column
data type.  When set to zero all rows are validated.</p>
</li>
<li><p class="first"><em>converterd</em>: if not <em>None</em>, is a dictionary mapping column number or
munged column name to a converter function.</p>
</li>
<li><p class="first"><em>names</em>: if not None, is a list of header names.  In this case, no
header will be read from the file</p>
</li>
<li><p class="first"><em>missingd</em> is a dictionary mapping munged column names to field values
which signify that the field does not contain actual data and should
be masked, e.g., &#8216;0000-00-00&#8217; or &#8216;unused&#8217;</p>
</li>
<li><p class="first"><em>missing</em>: a string whose value signals a missing field regardless of
the column it appears in</p>
</li>
<li><p class="first"><em>use_mrecords</em>: if True, return an mrecords.fromrecords record array if any of the data are missing</p>
</li>
<li><p class="first"><em>dayfirst</em>: default is False so that MM-DD-YY has precedence over
DD-MM-YY.  See <a class="reference external" href="http://labix.org/python-dateutil#head-b95ce2094d189a89f80f5ae52a05b4ab7b41af47">http://labix.org/python-dateutil#head-b95ce2094d189a89f80f5ae52a05b4ab7b41af47</a>
for further information.</p>
</li>
<li><p class="first"><em>yearfirst</em>: default is False so that MM-DD-YY has precedence over
YY-MM-DD.  See <a class="reference external" href="http://labix.org/python-dateutil#head-b95ce2094d189a89f80f5ae52a05b4ab7b41af47">http://labix.org/python-dateutil#head-b95ce2094d189a89f80f5ae52a05b4ab7b41af47</a>
for further information.</p>
<p>If no rows are found, <em>None</em> is returned &#8211; see <tt class="file docutils literal"><span class="pre">examples/loadrec.py</span></tt></p>
</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.csvformat_factory">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">csvformat_factory</tt><big>(</big><em>format</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.csvformat_factory" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.demean">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">demean</tt><big>(</big><em>x</em>, <em>axis=0</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.demean" title="Permalink to this definition">¶</a></dt>
<dd><p>Return x minus its mean along the specified axis</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.detrend">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">detrend</tt><big>(</big><em>x</em>, <em>key=None</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.detrend" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.detrend_linear">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">detrend_linear</tt><big>(</big><em>y</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.detrend_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Return y minus best fit line; &#8216;linear&#8217; detrending</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.detrend_mean">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">detrend_mean</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.detrend_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Return x minus the mean(x)</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.detrend_none">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">detrend_none</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.detrend_none" title="Permalink to this definition">¶</a></dt>
<dd><p>Return x: no detrending</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.dist">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">dist</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the distance between two points.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.dist_point_to_segment">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">dist_point_to_segment</tt><big>(</big><em>p</em>, <em>s0</em>, <em>s1</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.dist_point_to_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the distance of a point to a segment.</p>
<blockquote>
<div><em>p</em>, <em>s0</em>, <em>s1</em> are <em>xy</em> sequences</div></blockquote>
<p>This algorithm from
<a class="reference external" href="http://softsurfer.com/Archive/algorithm_0102/algorithm_0102.htm#Distance%20to%20Ray%20or%20Segment">http://softsurfer.com/Archive/algorithm_0102/algorithm_0102.htm#Distance%20to%20Ray%20or%20Segment</a></p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.distances_along_curve">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">distances_along_curve</tt><big>(</big><em>X</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.distances_along_curve" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the distance between a set of successive points in <em>N</em> dimensions.</p>
<p>Where <em>X</em> is an <em>M</em> x <em>N</em> array or matrix.  The distances between
successive rows is computed.  Distance is the standard Euclidean
distance.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.donothing_callback">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">donothing_callback</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.donothing_callback" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.entropy">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">entropy</tt><big>(</big><em>y</em>, <em>bins</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the entropy of the data in <em>y</em>.</p>
<img src="../_images/mathmpl/math-5c77f15b40.png" class="center" /><p>where <img src="../_images/mathmpl/math-6700e99fd3.png" style="position: relative; bottom: -7px"/> is the probability of observing <em>y</em> in the
<img src="../_images/mathmpl/math-fce1799ac3.png" style="position: relative; bottom: -3px"/> bin of <em>bins</em>.  <em>bins</em> can be a number of bins or a
range of bins; see <tt class="xref py py-func docutils literal"><span class="pre">numpy.histogram()</span></tt>.</p>
<p>Compare <em>S</em> with analytic calculation for a Gaussian:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">+</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">randn</span><span class="p">(</span><span class="mi">200000</span><span class="p">)</span>
<span class="n">Sanalytic</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">sigma</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.exp_safe">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">exp_safe</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.exp_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute exponentials which safely underflow to zero.</p>
<p>Slow, but convenient to use. Note that numpy provides proper
floating point exception handling with access to the underlying
hardware.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.fftsurr">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">fftsurr</tt><big>(</big><em>x</em>, <em>detrend=&lt;function detrend_none at 0x10a77d5f0&gt;</em>, <em>window=&lt;function window_none at 0x10a764b18&gt;</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.fftsurr" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an FFT phase randomized surrogate of <em>x</em>.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.find">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">find</tt><big>(</big><em>condition</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices where ravel(condition) is true</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.frange">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">frange</tt><big>(</big><span class="optional">[</span><em>start</em>, <span class="optional">]</span><em>stop</em><span class="optional">[</span>, <em>step</em>, <em>keywords</em><span class="optional">]</span><big>)</big> &rarr; array of floats<a class="headerlink" href="mlab_api.html#matplotlib.mlab.frange" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a numpy ndarray containing a progression of floats. Similar to
<tt class="xref py py-func docutils literal"><span class="pre">numpy.arange()</span></tt>, but defaults to a closed interval.</p>
<p><tt class="docutils literal"><span class="pre">frange(x0,</span> <span class="pre">x1)</span></tt> returns <tt class="docutils literal"><span class="pre">[x0,</span> <span class="pre">x0+1,</span> <span class="pre">x0+2,</span> <span class="pre">...,</span> <span class="pre">x1]</span></tt>; <em>start</em>
defaults to 0, and the endpoint <em>is included</em>. This behavior is
different from that of <tt class="xref py py-func docutils literal"><span class="pre">range()</span></tt> and
<tt class="xref py py-func docutils literal"><span class="pre">numpy.arange()</span></tt>. This is deliberate, since <a class="reference internal" href="mlab_api.html#matplotlib.mlab.frange" title="matplotlib.mlab.frange"><tt class="xref py py-func docutils literal"><span class="pre">frange()</span></tt></a>
will probably be more useful for generating lists of points for
function evaluation, and endpoints are often desired in this
use. The usual behavior of <tt class="xref py py-func docutils literal"><span class="pre">range()</span></tt> can be obtained by
setting the keyword <em>closed</em> = 0, in this case, <a class="reference internal" href="mlab_api.html#matplotlib.mlab.frange" title="matplotlib.mlab.frange"><tt class="xref py py-func docutils literal"><span class="pre">frange()</span></tt></a>
basically becomes :func:numpy.arange`.</p>
<p>When <em>step</em> is given, it specifies the increment (or
decrement). All arguments can be floating point numbers.</p>
<p><tt class="docutils literal"><span class="pre">frange(x0,x1,d)</span></tt> returns <tt class="docutils literal"><span class="pre">[x0,x0+d,x0+2d,...,xfin]</span></tt> where
<em>xfin</em> &lt;= <em>x1</em>.</p>
<p><a class="reference internal" href="mlab_api.html#matplotlib.mlab.frange" title="matplotlib.mlab.frange"><tt class="xref py py-func docutils literal"><span class="pre">frange()</span></tt></a> can also be called with the keyword <em>npts</em>. This
sets the number of points the list should contain (and overrides
the value <em>step</em> might have been given). <tt class="xref py py-func docutils literal"><span class="pre">numpy.arange()</span></tt>
doesn&#8217;t offer this option.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">frange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">array([ 0.,  1.,  2.,  3.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">closed</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 0.,  1.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([1, 3, 5])   or 1,3,5,7, depending on floating point vagueries</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mf">6.5</span><span class="p">,</span><span class="n">npts</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">array([ 1.   ,  2.375,  3.75 ,  5.125,  6.5  ])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.get_formatd">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">get_formatd</tt><big>(</big><em>r</em>, <em>formatd=None</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.get_formatd" title="Permalink to this definition">¶</a></dt>
<dd><p>build a formatd guaranteed to have a key for every dtype name</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.get_sparse_matrix">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">get_sparse_matrix</tt><big>(</big><em>M</em>, <em>N</em>, <em>frac=0.1</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.get_sparse_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <em>M</em> x <em>N</em> sparse matrix with <em>frac</em> elements randomly
filled.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.get_xyz_where">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">get_xyz_where</tt><big>(</big><em>Z</em>, <em>Cond</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.get_xyz_where" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Z</em> and <em>Cond</em> are <em>M</em> x <em>N</em> matrices.  <em>Z</em> are data and <em>Cond</em> is
a boolean matrix where some condition is satisfied.  Return value
is (<em>x</em>, <em>y</em>, <em>z</em>) where <em>x</em> and <em>y</em> are the indices into <em>Z</em> and
<em>z</em> are the values of <em>Z</em> at those indices.  <em>x</em>, <em>y</em>, and <em>z</em> are
1D arrays.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.griddata">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">griddata</tt><big>(</big><em>x</em>, <em>y</em>, <em>z</em>, <em>xi</em>, <em>yi</em>, <em>interp='nn'</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.griddata" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">zi</span> <span class="pre">=</span> <span class="pre">griddata(x,y,z,xi,yi)</span></tt> fits a surface of the form <em>z</em> =
<em>f*(*x</em>, <em>y</em>) to the data in the (usually) nonuniformly spaced
vectors (<em>x</em>, <em>y</em>, <em>z</em>).  <a class="reference internal" href="mlab_api.html#matplotlib.mlab.griddata" title="matplotlib.mlab.griddata"><tt class="xref py py-func docutils literal"><span class="pre">griddata()</span></tt></a> interpolates this
surface at the points specified by (<em>xi</em>, <em>yi</em>) to produce
<em>zi</em>. <em>xi</em> and <em>yi</em> must describe a regular grid, can be either 1D
or 2D, but must be monotonically increasing.</p>
<p>A masked array is returned if any grid points are outside convex
hull defined by input data (no extrapolation is done).</p>
<p>If interp keyword is set to &#8216;<tt class="xref py py-obj docutils literal"><span class="pre">nn</span></tt>&#8216; (default),
uses natural neighbor interpolation based on Delaunay
triangulation.  By default, this algorithm is provided by the
<tt class="xref py py-mod docutils literal"><span class="pre">matplotlib.delaunay</span></tt> package, written by Robert Kern.  The
triangulation algorithm in this package is known to fail on some
nearly pathological cases. For this reason, a separate toolkit
(<tt class="xref py py-mod docutils literal"><span class="pre">mpl_tookits.natgrid</span></tt>) has been created that provides a more
robust algorithm fof triangulation and interpolation.  This
toolkit is based on the NCAR natgrid library, which contains code
that is not redistributable under a BSD-compatible license.  When
installed, this function will use the <tt class="xref py py-mod docutils literal"><span class="pre">mpl_toolkits.natgrid</span></tt>
algorithm, otherwise it will use the built-in
<tt class="xref py py-mod docutils literal"><span class="pre">matplotlib.delaunay</span></tt> package.</p>
<p>If the interp keyword is set to &#8216;<tt class="xref py py-obj docutils literal"><span class="pre">linear</span></tt>&#8216;, then linear interpolation
is used instead of natural neighbor. In this case, the output grid
is assumed to be regular with a constant grid spacing in both the x and
y directions. For regular grids with nonconstant grid spacing, you
must use natural neighbor interpolation.  Linear interpolation is only valid if
<tt class="xref py py-mod docutils literal"><span class="pre">matplotlib.delaunay</span></tt> package is used - <tt class="xref py py-mod docutils literal"><span class="pre">mpl_tookits.natgrid</span></tt>
only provides natural neighbor interpolation.</p>
<p>The natgrid matplotlib toolkit can be downloaded from
<a class="reference external" href="http://sourceforge.net/project/showfiles.php?group_id=80706&amp;package_id=142792">http://sourceforge.net/project/showfiles.php?group_id=80706&amp;package_id=142792</a></p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.identity">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">identity</tt><big>(</big><em>n</em>, <em>rank=2</em>, <em>dtype='l'</em>, <em>typecode=None</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the identity matrix of shape (<em>n</em>, <em>n</em>, ..., <em>n</em>) (rank <em>r</em>).</p>
<p>For ranks higher than 2, this object is simply a multi-index Kronecker
delta:</p>
<div class="highlight-python"><div class="highlight"><pre>                    /  1  if i0=i1=...=iR,
id[i0,i1,...,iR] = -|
                    \  0  otherwise.
</pre></div>
</div>
<p>Optionally a <em>dtype</em> (or typecode) may be given (it defaults to &#8216;l&#8217;).</p>
<p>Since rank defaults to 2, this function behaves in the default case (when
only <em>n</em> is given) like <tt class="docutils literal"><span class="pre">numpy.identity(n)</span></tt> &#8211; but surprisingly, it is
much faster.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.inside_poly">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">inside_poly</tt><big>(</big><em>points</em>, <em>verts</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.inside_poly" title="Permalink to this definition">¶</a></dt>
<dd><p><em>points</em> is a sequence of <em>x</em>, <em>y</em> points.
<em>verts</em> is a sequence of <em>x</em>, <em>y</em> vertices of a polygon.</p>
<p>Return value is a sequence of indices into points for the points
that are inside the polygon.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.is_closed_polygon">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">is_closed_polygon</tt><big>(</big><em>X</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.is_closed_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether first and last object in a sequence are the same.  These are
presumably coordinates on a polygonal curve, in which case this function
tests if that curve is closed.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.ispower2">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">ispower2</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.ispower2" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the log base 2 of <em>n</em> if <em>n</em> is a power of 2, zero otherwise.</p>
<p>Note the potential ambiguity if <em>n</em> == 1: 2**0 == 1, interpret accordingly.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.isvector">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">isvector</tt><big>(</big><em>X</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.isvector" title="Permalink to this definition">¶</a></dt>
<dd><p>Like the MATLAB function with the same name, returns <em>True</em>
if the supplied numpy array or matrix <em>X</em> looks like a vector,
meaning it has a one non-singleton axis (i.e., it can have
multiple axes, but all must have length 1, except for one of
them).</p>
<p>If you just want to see if the array has 1 axis, use X.ndim == 1.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.l1norm">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">l1norm</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.l1norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <em>l1</em> norm of <em>a</em>, flattened out.</p>
<p>Implemented as a separate function (not a call to <tt class="xref py py-func docutils literal"><span class="pre">norm()</span></tt> for speed).</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.l2norm">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">l2norm</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.l2norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <em>l2</em> norm of <em>a</em>, flattened out.</p>
<p>Implemented as a separate function (not a call to <tt class="xref py py-func docutils literal"><span class="pre">norm()</span></tt> for speed).</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.less_simple_linear_interpolation">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">less_simple_linear_interpolation</tt><big>(</big><em>x</em>, <em>y</em>, <em>xi</em>, <em>extrap=False</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.less_simple_linear_interpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>This function provides simple (but somewhat less so than
<tt class="xref py py-func docutils literal"><span class="pre">cbook.simple_linear_interpolation()</span></tt>) linear interpolation.
<tt class="xref py py-func docutils literal"><span class="pre">simple_linear_interpolation()</span></tt> will give a list of point
between a start and an end, while this does true linear
interpolation at an arbitrary set of points.</p>
<p>This is very inefficient linear interpolation meant to be used
only for a small number of points in relatively non-intensive use
cases.  For real linear interpolation, use scipy.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.levypdf">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">levypdf</tt><big>(</big><em>x</em>, <em>gamma</em>, <em>alpha</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.levypdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returm the levy pdf evaluated at <em>x</em> for params <em>gamma</em>, <em>alpha</em></p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.log2">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">log2</tt><big>(</big><em>x</em>, <em>ln2=0.6931471805599453</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.log2" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the log(<em>x</em>) in base 2.</p>
<p>This is a _slow_ function but which is guaranteed to return the correct
integer value if the input is an integer exact power of 2.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.logspace">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">logspace</tt><big>(</big><em>xmin</em>, <em>xmax</em>, <em>N</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.logspace" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.longest_contiguous_ones">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">longest_contiguous_ones</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.longest_contiguous_ones" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of the longest stretch of contiguous ones in <em>x</em>,
assuming <em>x</em> is a vector of zeros and ones.  If there are two
equally long stretches, pick the first.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.longest_ones">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">longest_ones</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.longest_ones" title="Permalink to this definition">¶</a></dt>
<dd><p>alias for longest_contiguous_ones</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.movavg">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">movavg</tt><big>(</big><em>x</em>, <em>n</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.movavg" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the len(<em>n</em>) moving average of <em>x</em>.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.norm_flat">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">norm_flat</tt><big>(</big><em>a</em>, <em>p=2</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.norm_flat" title="Permalink to this definition">¶</a></dt>
<dd><p>norm(a,p=2) -&gt; l-p norm of a.flat</p>
<p>Return the l-p norm of <em>a</em>, considered as a flat array.  This is NOT a true
matrix norm, since arrays of arbitrary rank are always flattened.</p>
<p><em>p</em> can be a number or the string &#8216;Infinity&#8217; to get the L-infinity norm.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.normpdf">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">normpdf</tt><big>(</big><em>x</em>, <em>*args</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.normpdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the normal pdf evaluated at <em>x</em>; args provides <em>mu</em>, <em>sigma</em></p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.offset_line">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">offset_line</tt><big>(</big><em>y</em>, <em>yerr</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.offset_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Offsets an array <em>y</em> by +/- an error and returns a tuple (y - err, y + err).</p>
<p>The error term can be:</p>
<ul>
<li><p class="first">A scalar. In this case, the returned tuple is obvious.</p>
</li>
<li><p class="first">A vector of the same length as <em>y</em>. The quantities y +/- err are computed
component-wise.</p>
</li>
<li><p class="first">A tuple of length 2. In this case, yerr[0] is the error below <em>y</em> and
yerr[1] is error above <em>y</em>. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">y_minus</span><span class="p">,</span> <span class="n">y_plus</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">offset_line</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">fill_between</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ym</span><span class="p">,</span> <span class="n">y2</span><span class="o">=</span><span class="n">yp</span><span class="p">)</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.path_length">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">path_length</tt><big>(</big><em>X</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.path_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the distance travelled along a polygonal curve in <em>N</em> dimensions.</p>
<p>Where <em>X</em> is an <em>M</em> x <em>N</em> array or matrix.  Returns an array of
length <em>M</em> consisting of the distance along the curve at each point
(i.e., the rows of <em>X</em>).</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.poly_below">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">poly_below</tt><big>(</big><em>xmin</em>, <em>xs</em>, <em>ys</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.poly_below" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of <em>xs</em> and <em>ys</em>, return the vertices of a
polygon that has a horizontal base at <em>xmin</em> and an upper bound at
the <em>ys</em>.  <em>xmin</em> is a scalar.</p>
<p>Intended for use with <a class="reference internal" href="axes_api.html#matplotlib.axes.Axes.fill" title="matplotlib.axes.Axes.fill"><tt class="xref py py-meth docutils literal"><span class="pre">matplotlib.axes.Axes.fill()</span></tt></a>, eg:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">poly_below</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.poly_between">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">poly_between</tt><big>(</big><em>x</em>, <em>ylower</em>, <em>yupper</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.poly_between" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of <em>x</em>, <em>ylower</em> and <em>yupper</em>, return the polygon
that fills the regions between them.  <em>ylower</em> or <em>yupper</em> can be
scalar or iterable.  If they are iterable, they must be equal in
length to <em>x</em>.</p>
<p>Return value is <em>x</em>, <em>y</em> arrays for use with
<a class="reference internal" href="axes_api.html#matplotlib.axes.Axes.fill" title="matplotlib.axes.Axes.fill"><tt class="xref py py-meth docutils literal"><span class="pre">matplotlib.axes.Axes.fill()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.prctile">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">prctile</tt><big>(</big><em>x</em>, <em>p=(0.0</em>, <em>25.0</em>, <em>50.0</em>, <em>75.0</em>, <em>100.0)</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.prctile" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the percentiles of <em>x</em>.  <em>p</em> can either be a sequence of
percentile values or a scalar.  If <em>p</em> is a sequence, the ith
element of the return sequence is the <em>p*(i)-th percentile of *x</em>.
If <em>p</em> is a scalar, the largest value of <em>x</em> less than or equal to
the <em>p</em> percentage point in the sequence is returned.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.prctile_rank">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">prctile_rank</tt><big>(</big><em>x</em>, <em>p</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.prctile_rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the rank for each element in <em>x</em>, return the rank
0..len(<em>p</em>).  e.g., if <em>p</em> = (25, 50, 75), the return value will be a
len(<em>x</em>) array with values in [0,1,2,3] where 0 indicates the
value is less than the 25th percentile, 1 indicates the value is
&gt;= the 25th and &lt; 50th percentile, ... and 3 indicates the value
is above the 75th percentile cutoff.</p>
<p><em>p</em> is either an array of percentiles in [0..100] or a scalar which
indicates how many quantiles of data you want ranked.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.prepca">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">prepca</tt><big>(</big><em>P</em>, <em>frac=0</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.prepca" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING: this function is deprecated &#8211; please see class PCA instead</p>
<p>Compute the principal components of <em>P</em>.  <em>P</em> is a (<em>numVars</em>,
<em>numObs</em>) array.  <em>frac</em> is the minimum fraction of variance that a
component must contain to be included.</p>
<p>Return value is a tuple of the form (<em>Pcomponents</em>, <em>Trans</em>,
<em>fracVar</em>) where:</p>
<blockquote>
<div><ul>
<li><p class="first"><em>Pcomponents</em> : a (numVars, numObs) array</p>
</li>
<li><dl class="first docutils">
<dt><em>Trans</em> <span class="classifier-delimiter">:</span> <span class="classifier">the weights matrix, ie, <em>Pcomponents</em> = <em>Trans</em> *</span></dt>
<dd><p class="first last"><em>P</em></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>fracVar</em> <span class="classifier-delimiter">:</span> <span class="classifier">the fraction of the variance accounted for by each</span></dt>
<dd><p class="first last">component returned</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>A similar function of the same name was in the MATLAB
R13 Neural Network Toolbox but is not found in later versions;
its successor seems to be called &#8220;processpcs&#8221;.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.psd">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">psd</tt><big>(</big><em>x</em>, <em>NFFT=256</em>, <em>Fs=2</em>, <em>detrend=&lt;function detrend_none at 0x10a77d5f0&gt;</em>, <em>window=&lt;function window_hanning at 0x10a7646e0&gt;</em>, <em>noverlap=0</em>, <em>pad_to=None</em>, <em>sides='default'</em>, <em>scale_by_freq=None</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.psd" title="Permalink to this definition">¶</a></dt>
<dd><p>The power spectral density by Welch&#8217;s average periodogram method.
The vector <em>x</em> is divided into <em>NFFT</em> length blocks.  Each block
is detrended by the function <em>detrend</em> and windowed by the function
<em>window</em>.  <em>noverlap</em> gives the length of the overlap between blocks.
The absolute(fft(block))**2 of each segment are averaged to compute
<em>Pxx</em>, with a scaling to correct for power loss due to windowing.</p>
<p>If len(<em>x</em>) &lt; <em>NFFT</em>, it will be zero padded to <em>NFFT</em>.</p>
<dl class="docutils">
<dt><em>x</em></dt>
<dd>Array or sequence containing the data</dd>
</dl>
<p>Keyword arguments:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>NFFT</em>: integer</dt>
<dd>The number of data points used in each block for the FFT.
Must be even; a power 2 is most efficient.  The default value is 256.
This should <em>NOT</em> be used to get zero padding, or the scaling of the
result will be incorrect. Use <em>pad_to</em> for this instead.</dd>
<dt><em>Fs</em>: scalar</dt>
<dd>The sampling frequency (samples per time unit).  It is used
to calculate the Fourier frequencies, freqs, in cycles per time
unit. The default value is 2.</dd>
<dt><em>detrend</em>: callable</dt>
<dd>The function applied to each segment before fft-ing,
designed to remove the mean or linear trend.  Unlike in
MATLAB, where the <em>detrend</em> parameter is a vector, in
matplotlib is it a function.  The <tt class="xref py py-mod docutils literal"><span class="pre">pylab</span></tt>
module defines <tt class="xref py py-func docutils literal"><span class="pre">detrend_none()</span></tt>,
<tt class="xref py py-func docutils literal"><span class="pre">detrend_mean()</span></tt>, and
<tt class="xref py py-func docutils literal"><span class="pre">detrend_linear()</span></tt>, but you can use
a custom function as well.</dd>
<dt><em>window</em>: callable or ndarray</dt>
<dd>A function or a vector of length <em>NFFT</em>. To create window
vectors see <a class="reference internal" href="mlab_api.html#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><tt class="xref py py-func docutils literal"><span class="pre">window_hanning()</span></tt></a>, <a class="reference internal" href="mlab_api.html#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><tt class="xref py py-func docutils literal"><span class="pre">window_none()</span></tt></a>,
<tt class="xref py py-func docutils literal"><span class="pre">numpy.blackman()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">numpy.hamming()</span></tt>,
<tt class="xref py py-func docutils literal"><span class="pre">numpy.bartlett()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">scipy.signal()</span></tt>,
<tt class="xref py py-func docutils literal"><span class="pre">scipy.signal.get_window()</span></tt>, etc. The default is
<a class="reference internal" href="mlab_api.html#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><tt class="xref py py-func docutils literal"><span class="pre">window_hanning()</span></tt></a>.  If a function is passed as the
argument, it must take a data segment as an argument and
return the windowed version of the segment.</dd>
<dt><em>pad_to</em>: integer</dt>
<dd>The number of points to which the data segment is padded when
performing the FFT.  This can be different from <em>NFFT</em>, which
specifies the number of data points used.  While not increasing
the actual resolution of the psd (the minimum distance between
resolvable peaks), this can give more points in the plot,
allowing for more detail. This corresponds to the <em>n</em> parameter
in the call to fft(). The default is None, which sets <em>pad_to</em>
equal to <em>NFFT</em></dd>
<dt><em>sides</em>: [ &#8216;default&#8217; | &#8216;onesided&#8217; | &#8216;twosided&#8217; ]</dt>
<dd>Specifies which sides of the PSD to return.  Default gives the
default behavior, which returns one-sided for real data and both
for complex data.  &#8216;onesided&#8217; forces the return of a one-sided PSD,
while &#8216;twosided&#8217; forces two-sided.</dd>
<dt><em>scale_by_freq</em>: boolean</dt>
<dd>Specifies whether the resulting density values should be scaled
by the scaling frequency, which gives density in units of Hz^-1.
This allows for integration over the returned frequency values.
The default is True for MATLAB compatibility.</dd>
<dt><em>noverlap</em>: integer</dt>
<dd>The number of points of overlap between blocks.  The default value
is 0 (no overlap).</dd>
</dl>
</div></blockquote>
<p>Returns the tuple (<em>Pxx</em>, <em>freqs</em>).</p>
<p>Refs:</p>
<blockquote>
<div>Bendat &amp; Piersol &#8211; Random Data: Analysis and Measurement
Procedures, John Wiley &amp; Sons (1986)</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.quad2cubic">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">quad2cubic</tt><big>(</big><em>q0x</em>, <em>q0y</em>, <em>q1x</em>, <em>q1y</em>, <em>q2x</em>, <em>q2y</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.quad2cubic" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a quadratic Bezier curve to a cubic approximation.</p>
<p>The inputs are the <em>x</em> and <em>y</em> coordinates of the three control
points of a quadratic curve, and the output is a tuple of <em>x</em> and
<em>y</em> coordinates of the four control points of the cubic curve.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.rec2csv">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">rec2csv</tt><big>(</big><em>r</em>, <em>fname</em>, <em>delimiter='</em>, <em>'</em>, <em>formatd=None</em>, <em>missing=''</em>, <em>missingd=None</em>, <em>withheader=True</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.rec2csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the data from numpy recarray <em>r</em> into a
comma-/space-/tab-delimited file.  The record array dtype names
will be used for column headers.</p>
<dl class="docutils">
<dt><em>fname</em>: can be a filename or a file handle.  Support for gzipped</dt>
<dd>files is automatic, if the filename ends in &#8216;.gz&#8217;</dd>
<dt><em>withheader</em>: if withheader is False, do not write the attribute</dt>
<dd>names in the first row</dd>
</dl>
<p>for formatd type FormatFloat, we override the precision to store
full precision floats in the CSV file</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.csv2rec" title="matplotlib.mlab.csv2rec"><tt class="xref py py-func docutils literal"><span class="pre">csv2rec()</span></tt></a></dt>
<dd>For information about <em>missing</em> and <em>missingd</em>, which can
be used to fill in masked values into your CSV file.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.rec2txt">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">rec2txt</tt><big>(</big><em>r</em>, <em>header=None</em>, <em>padding=3</em>, <em>precision=3</em>, <em>fields=None</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.rec2txt" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a textual representation of a record array.</p>
<p><em>r</em>: numpy recarray</p>
<p><em>header</em>: list of column headers</p>
<p><em>padding</em>: space between each column</p>
<dl class="docutils">
<dt><em>precision</em>: number of decimal places to use for floats.</dt>
<dd>Set to an integer to apply to all floats.  Set to a
list of integers to apply precision individually.
Precision for non-floats is simply ignored.</dd>
</dl>
<p><em>fields</em> : if not None, a list of field names to print.  fields
can be a list of strings like [&#8216;field1&#8217;, &#8216;field2&#8217;] or a single
comma separated string like &#8216;field1,field2&#8217;</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">precision</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python"><div class="highlight"><pre>ID    Price   Return
ABC   12.54    0.234
XYZ    6.32   -0.076
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.rec_append_fields">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">rec_append_fields</tt><big>(</big><em>rec</em>, <em>names</em>, <em>arrs</em>, <em>dtypes=None</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.rec_append_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new record array with field names populated with data
from arrays in <em>arrs</em>.  If appending a single field, then <em>names</em>,
<em>arrs</em> and <em>dtypes</em> do not have to be lists. They can just be the
values themselves.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.rec_drop_fields">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">rec_drop_fields</tt><big>(</big><em>rec</em>, <em>names</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.rec_drop_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new numpy record array with fields in <em>names</em> dropped.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.rec_groupby">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">rec_groupby</tt><big>(</big><em>r</em>, <em>groupby</em>, <em>stats</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.rec_groupby" title="Permalink to this definition">¶</a></dt>
<dd><p><em>r</em> is a numpy record array</p>
<p><em>groupby</em> is a sequence of record array attribute names that
together form the grouping key.  eg (&#8216;date&#8217;, &#8216;productcode&#8217;)</p>
<p><em>stats</em> is a sequence of (<em>attr</em>, <em>func</em>, <em>outname</em>) tuples which
will call <tt class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">func(attr)</span></tt> and assign <em>x</em> to the record array
output with attribute <em>outname</em>.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">stats</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="s">&#39;sales&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">,</span> <span class="s">&#39;numsales&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;sales&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="s">&#39;avgsale&#39;</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>Return record array has <em>dtype</em> names for each attribute name in
the the <em>groupby</em> argument, with the associated group values, and
for each outname name in the <em>stats</em> argument, with the associated
stat summary output.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.rec_join">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">rec_join</tt><big>(</big><em>key</em>, <em>r1</em>, <em>r2</em>, <em>jointype='inner'</em>, <em>defaults=None</em>, <em>r1postfix='1'</em>, <em>r2postfix='2'</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.rec_join" title="Permalink to this definition">¶</a></dt>
<dd><p>Join record arrays <em>r1</em> and <em>r2</em> on <em>key</em>; <em>key</em> is a tuple of
field names &#8211; if <em>key</em> is a string it is assumed to be a single
attribute name. If <em>r1</em> and <em>r2</em> have equal values on all the keys
in the <em>key</em> tuple, then their fields will be merged into a new
record array containing the intersection of the fields of <em>r1</em> and
<em>r2</em>.</p>
<p><em>r1</em> (also <em>r2</em>) must not have any duplicate keys.</p>
<p>The <em>jointype</em> keyword can be &#8216;inner&#8217;, &#8216;outer&#8217;, &#8216;leftouter&#8217;.  To
do a rightouter join just reverse <em>r1</em> and <em>r2</em>.</p>
<p>The <em>defaults</em> keyword is a dictionary filled with
<tt class="docutils literal"><span class="pre">{column_name:default_value}</span></tt> pairs.</p>
<p>The keywords <em>r1postfix</em> and <em>r2postfix</em> are postfixed to column names
(other than keys) that are both in <em>r1</em> and <em>r2</em>.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.rec_keep_fields">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">rec_keep_fields</tt><big>(</big><em>rec</em>, <em>names</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.rec_keep_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new numpy record array with only fields listed in names</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.rec_summarize">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">rec_summarize</tt><big>(</big><em>r</em>, <em>summaryfuncs</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.rec_summarize" title="Permalink to this definition">¶</a></dt>
<dd><p><em>r</em> is a numpy record array</p>
<p><em>summaryfuncs</em> is a list of (<em>attr</em>, <em>func</em>, <em>outname</em>) tuples
which will apply <em>func</em> to the the array <em>r*[attr] and assign the
output to a new attribute name *outname</em>.  The returned record
array is identical to <em>r</em>, with extra arrays for each element in
<em>summaryfuncs</em>.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.recs_join">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">recs_join</tt><big>(</big><em>key</em>, <em>name</em>, <em>recs</em>, <em>jointype='outer'</em>, <em>missing=0.0</em>, <em>postfixes=None</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.recs_join" title="Permalink to this definition">¶</a></dt>
<dd><p>Join a sequence of record arrays on single column key.</p>
<p>This function only joins a single column of the multiple record arrays</p>
<dl class="docutils">
<dt><em>key</em></dt>
<dd>is the column name that acts as a key</dd>
<dt><em>name</em></dt>
<dd>is the name of the column that we want to join</dd>
<dt><em>recs</em></dt>
<dd>is a list of record arrays to join</dd>
<dt><em>jointype</em></dt>
<dd>is a string &#8216;inner&#8217; or &#8216;outer&#8217;</dd>
<dt><em>missing</em></dt>
<dd>is what any missing field is replaced by</dd>
<dt><em>postfixes</em></dt>
<dd>if not None, a len recs sequence of postfixes</dd>
</dl>
<p>returns a record array with columns [rowkey, name0, name1, ... namen-1].
or if postfixes [PF0, PF1, ..., PFN-1] are supplied,
[rowkey, namePF0, namePF1, ... namePFN-1].</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">r</span> <span class="o">=</span> <span class="n">recs_join</span><span class="p">(</span><span class="s">&quot;date&quot;</span><span class="p">,</span> <span class="s">&quot;close&quot;</span><span class="p">,</span> <span class="n">recs</span><span class="o">=</span><span class="p">[</span><span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="p">],</span> <span class="n">missing</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.rk4">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">rk4</tt><big>(</big><em>derivs</em>, <em>y0</em>, <em>t</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.rk4" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrate 1D or ND system of ODEs using 4-th order Runge-Kutta.
This is a toy implementation which may be useful if you find
yourself stranded on a system w/o scipy.  Otherwise use
<tt class="xref py py-func docutils literal"><span class="pre">scipy.integrate()</span></tt>.</p>
<dl class="docutils">
<dt><em>y0</em></dt>
<dd>initial state vector</dd>
<dt><em>t</em></dt>
<dd>sample times</dd>
<dt><em>derivs</em></dt>
<dd>returns the derivative of the system and has the
signature <tt class="docutils literal"><span class="pre">dy</span> <span class="pre">=</span> <span class="pre">derivs(yi,</span> <span class="pre">ti)</span></tt></dd>
</dl>
<p>Example 1</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">## 2D system</span>

<span class="k">def</span> <span class="nf">derivs6</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
    <span class="n">d1</span> <span class="o">=</span>  <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">d2</span> <span class="o">=</span>  <span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">)</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.0005</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
<span class="n">y0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">yout</span> <span class="o">=</span> <span class="n">rk4</span><span class="p">(</span><span class="n">derivs6</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>Example 2:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">## 1D system</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mi">2</span>
<span class="k">def</span> <span class="nf">derivs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="p">)</span>

<span class="n">y0</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">yout</span> <span class="o">=</span> <span class="n">rk4</span><span class="p">(</span><span class="n">derivs</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>If you have access to scipy, you should probably be using the
scipy.integrate tools rather than this function.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.rms_flat">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">rms_flat</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.rms_flat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the root mean square of all the elements of <em>a</em>, flattened out.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.safe_isinf">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">safe_isinf</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.safe_isinf" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref py py-func docutils literal"><span class="pre">numpy.isinf()</span></tt> for arbitrary types</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.safe_isnan">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">safe_isnan</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.safe_isnan" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref py py-func docutils literal"><span class="pre">numpy.isnan()</span></tt> for arbitrary types</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.segments_intersect">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">segments_intersect</tt><big>(</big><em>s1</em>, <em>s2</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.segments_intersect" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <em>True</em> if <em>s1</em> and <em>s2</em> intersect.
<em>s1</em> and <em>s2</em> are defined as:</p>
<div class="highlight-python"><div class="highlight"><pre>s1: (x1, y1), (x2, y2)
s2: (x3, y3), (x4, y4)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.slopes">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">slopes</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.slopes" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="mlab_api.html#matplotlib.mlab.slopes" title="matplotlib.mlab.slopes"><tt class="xref py py-func docutils literal"><span class="pre">slopes()</span></tt></a> calculates the slope <em>y</em>&#8216;(<em>x</em>)</p>
<p>The slope is estimated using the slope obtained from that of a
parabola through any three consecutive points.</p>
<p>This method should be superior to that described in the appendix
of A CONSISTENTLY WELL BEHAVED METHOD OF INTERPOLATION by Russel
W. Stineman (Creative Computing July 1980) in at least one aspect:</p>
<blockquote>
<div>Circles for interpolation demand a known aspect ratio between
<em>x</em>- and <em>y</em>-values.  For many functions, however, the abscissa
are given in different dimensions, so an aspect ratio is
completely arbitrary.</div></blockquote>
<p>The parabola method gives very similar results to the circle
method for most regular cases but behaves much better in special
cases.</p>
<p>Norbert Nemec, Institute of Theoretical Physics, University or
Regensburg, April 2006 Norbert.Nemec at physik.uni-regensburg.de</p>
<p>(inspired by a original implementation by Halldor Bjornsson,
Icelandic Meteorological Office, March 2006 halldor at vedur.is)</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.specgram">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">specgram</tt><big>(</big><em>x</em>, <em>NFFT=256</em>, <em>Fs=2</em>, <em>detrend=&lt;function detrend_none at 0x10a77d5f0&gt;</em>, <em>window=&lt;function window_hanning at 0x10a7646e0&gt;</em>, <em>noverlap=128</em>, <em>pad_to=None</em>, <em>sides='default'</em>, <em>scale_by_freq=None</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.specgram" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a spectrogram of data in <em>x</em>.  Data are split into <em>NFFT</em>
length segments and the PSD of each section is computed.  The
windowing function <em>window</em> is applied to each segment, and the
amount of overlap of each segment is specified with <em>noverlap</em>.</p>
<p>If <em>x</em> is real (i.e. non-complex) only the spectrum of the positive
frequencie is returned.  If <em>x</em> is complex then the complete
spectrum is returned.</p>
<p>Keyword arguments:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>NFFT</em>: integer</dt>
<dd>The number of data points used in each block for the FFT.
Must be even; a power 2 is most efficient.  The default value is 256.
This should <em>NOT</em> be used to get zero padding, or the scaling of the
result will be incorrect. Use <em>pad_to</em> for this instead.</dd>
<dt><em>Fs</em>: scalar</dt>
<dd>The sampling frequency (samples per time unit).  It is used
to calculate the Fourier frequencies, freqs, in cycles per time
unit. The default value is 2.</dd>
<dt><em>detrend</em>: callable</dt>
<dd>The function applied to each segment before fft-ing,
designed to remove the mean or linear trend.  Unlike in
MATLAB, where the <em>detrend</em> parameter is a vector, in
matplotlib is it a function.  The <tt class="xref py py-mod docutils literal"><span class="pre">pylab</span></tt>
module defines <tt class="xref py py-func docutils literal"><span class="pre">detrend_none()</span></tt>,
<tt class="xref py py-func docutils literal"><span class="pre">detrend_mean()</span></tt>, and
<tt class="xref py py-func docutils literal"><span class="pre">detrend_linear()</span></tt>, but you can use
a custom function as well.</dd>
<dt><em>window</em>: callable or ndarray</dt>
<dd>A function or a vector of length <em>NFFT</em>. To create window
vectors see <a class="reference internal" href="mlab_api.html#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><tt class="xref py py-func docutils literal"><span class="pre">window_hanning()</span></tt></a>, <a class="reference internal" href="mlab_api.html#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><tt class="xref py py-func docutils literal"><span class="pre">window_none()</span></tt></a>,
<tt class="xref py py-func docutils literal"><span class="pre">numpy.blackman()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">numpy.hamming()</span></tt>,
<tt class="xref py py-func docutils literal"><span class="pre">numpy.bartlett()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">scipy.signal()</span></tt>,
<tt class="xref py py-func docutils literal"><span class="pre">scipy.signal.get_window()</span></tt>, etc. The default is
<a class="reference internal" href="mlab_api.html#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><tt class="xref py py-func docutils literal"><span class="pre">window_hanning()</span></tt></a>.  If a function is passed as the
argument, it must take a data segment as an argument and
return the windowed version of the segment.</dd>
<dt><em>pad_to</em>: integer</dt>
<dd>The number of points to which the data segment is padded when
performing the FFT.  This can be different from <em>NFFT</em>, which
specifies the number of data points used.  While not increasing
the actual resolution of the psd (the minimum distance between
resolvable peaks), this can give more points in the plot,
allowing for more detail. This corresponds to the <em>n</em> parameter
in the call to fft(). The default is None, which sets <em>pad_to</em>
equal to <em>NFFT</em></dd>
<dt><em>sides</em>: [ &#8216;default&#8217; | &#8216;onesided&#8217; | &#8216;twosided&#8217; ]</dt>
<dd>Specifies which sides of the PSD to return.  Default gives the
default behavior, which returns one-sided for real data and both
for complex data.  &#8216;onesided&#8217; forces the return of a one-sided PSD,
while &#8216;twosided&#8217; forces two-sided.</dd>
<dt><em>scale_by_freq</em>: boolean</dt>
<dd>Specifies whether the resulting density values should be scaled
by the scaling frequency, which gives density in units of Hz^-1.
This allows for integration over the returned frequency values.
The default is True for MATLAB compatibility.</dd>
<dt><em>noverlap</em>: integer</dt>
<dd>The number of points of overlap between blocks.  The default value
is 128.</dd>
</dl>
</div></blockquote>
<p>Returns a tuple (<em>Pxx</em>, <em>freqs</em>, <em>t</em>):</p>
<blockquote>
<div><ul class="simple">
<li><em>Pxx</em>: 2-D array, columns are the periodograms of
successive segments</li>
<li><em>freqs</em>: 1-D array of frequencies corresponding to the rows
in Pxx</li>
<li><em>t</em>: 1-D array of times corresponding to midpoints of
segments.</li>
</ul>
</div></blockquote>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="mlab_api.html#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><tt class="xref py py-func docutils literal"><span class="pre">psd()</span></tt></a></dt>
<dd><a class="reference internal" href="mlab_api.html#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><tt class="xref py py-func docutils literal"><span class="pre">psd()</span></tt></a> differs in the default overlap; in returning
the mean of the segment periodograms; and in not returning
times.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.stineman_interp">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">stineman_interp</tt><big>(</big><em>xi</em>, <em>x</em>, <em>y</em>, <em>yp=None</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.stineman_interp" title="Permalink to this definition">¶</a></dt>
<dd><p>Given data vectors <em>x</em> and <em>y</em>, the slope vector <em>yp</em> and a new
abscissa vector <em>xi</em>, the function <a class="reference internal" href="mlab_api.html#matplotlib.mlab.stineman_interp" title="matplotlib.mlab.stineman_interp"><tt class="xref py py-func docutils literal"><span class="pre">stineman_interp()</span></tt></a> uses
Stineman interpolation to calculate a vector <em>yi</em> corresponding to
<em>xi</em>.</p>
<p>Here&#8217;s an example that generates a coarse sine curve, then
interpolates over a finer abscissa:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span>  <span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="n">yp</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">xi</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">,</span><span class="mi">40</span><span class="p">);</span>
<span class="n">yi</span> <span class="o">=</span> <span class="n">stineman_interp</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">yp</span><span class="p">);</span>
<span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="s">&#39;o&#39;</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">yi</span><span class="p">)</span>
</pre></div>
</div>
<p>The interpolation method is described in the article A
CONSISTENTLY WELL BEHAVED METHOD OF INTERPOLATION by Russell
W. Stineman. The article appeared in the July 1980 issue of
Creative Computing with a note from the editor stating that while
they were:</p>
<blockquote>
<div>not an academic journal but once in a while something serious
and original comes in adding that this was
&#8220;apparently a real solution&#8221; to a well known problem.</div></blockquote>
<p>For <em>yp</em> = <em>None</em>, the routine automatically determines the slopes
using the <a class="reference internal" href="mlab_api.html#matplotlib.mlab.slopes" title="matplotlib.mlab.slopes"><tt class="xref py py-func docutils literal"><span class="pre">slopes()</span></tt></a> routine.</p>
<p><em>x</em> is assumed to be sorted in increasing order.</p>
<p>For values <tt class="docutils literal"><span class="pre">xi[j]</span> <span class="pre">&lt;</span> <span class="pre">x[0]</span></tt> or <tt class="docutils literal"><span class="pre">xi[j]</span> <span class="pre">&gt;</span> <span class="pre">x[-1]</span></tt>, the routine
tries an extrapolation.  The relevance of the data obtained from
this, of course, is questionable...</p>
<p>Original implementation by Halldor Bjornsson, Icelandic
Meteorolocial Office, March 2006 halldor at vedur.is</p>
<p>Completely reworked and optimized for Python by Norbert Nemec,
Institute of Theoretical Physics, University or Regensburg, April
2006 Norbert.Nemec at physik.uni-regensburg.de</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.vector_lengths">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">vector_lengths</tt><big>(</big><em>X</em>, <em>P=2.0</em>, <em>axis=None</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.vector_lengths" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the length of a set of vectors in <em>n</em> dimensions.  This is
like the <tt class="xref py py-func docutils literal"><span class="pre">numpy.norm()</span></tt> function for vectors, but has the ability to
work over a particular axis of the supplied array or matrix.</p>
<p>Computes <tt class="docutils literal"><span class="pre">(sum((x_i)^P))^(1/P)</span></tt> for each <tt class="docutils literal"><span class="pre">{x_i}</span></tt> being the
elements of <em>X</em> along the given axis.  If <em>axis</em> is <em>None</em>,
compute over all elements of <em>X</em>.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.window_hanning">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">window_hanning</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.window_hanning" title="Permalink to this definition">¶</a></dt>
<dd><p>return x times the hanning window of len(x)</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.window_none">
<tt class="descclassname">matplotlib.mlab.</tt><tt class="descname">window_none</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="mlab_api.html#matplotlib.mlab.window_none" title="Permalink to this definition">¶</a></dt>
<dd><p>No window function; simply return x</p>
</dd></dl>

</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
    &copy; <a href="http://omz-software.com/pythonista/matplotlib/copyright.html">Copyright</a> 2002 - 2012 John Hunter, Darren Dale, Eric Firing, Michael Droettboom and the matplotlib development team; 2012 - 2013 The matplotlib development team.
    <br />
    The Python Software Foundation is a non-profit corporation.  
    <a href="http://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on May 03, 2016.
    <a href="http://omz-software.com/pythonista/matplotlib/bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.1.
    </div>

  </body>
</html>