
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>triangular grids &mdash; Matplotlib 1.3.1 documentation</title>
    <link rel="stylesheet" href="../_static/pythonista.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.3.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Matplotlib 1.3.1 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="top" title="Matplotlib 1.3.1 documentation" href="../index.html" />
    <link rel="up" title="The Matplotlib API" href="index.html" />
    <link rel="prev" title="tight_layout" href="tight_layout_api.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="stylesheet" href="../_static/pythonista.css" type="text/css" />
    <meta name = "viewport" content = "width=device-width,initial-scale=1.0,user-scalable=no;">
    
    <script type="text/javascript">
        var getTextForSample = function(i) {
            codeBlock = document.getElementsByClassName('highlight-python')[i];
            return codeBlock.innerText;
        }
        
        var copySample = function (i) {
            window.location.href = '/__pythonista_copy__/' + encodeURI(getTextForSample(i));
        }
        
        var openSample = function (i) {
            window.location.href = '/__pythonista_open__/' + encodeURI(getTextForSample(i));
        }
        
        //Source: http://ejohn.org/blog/partial-functions-in-javascript/
        Function.prototype.partial = function() {
        	var fn = this,
        		args = Array.prototype.slice.call(arguments);
        	return function() {
        		var arg = 0;
        		for (var i = 0; i < args.length && arg < arguments.length; i++)
        		if (args[i] === undefined) args[i] = arguments[arg++];
        		return fn.apply(this, args);
        	};
        };
        
        window.onload=function() {
            //Add "Copy" and "Open in Editor" buttons for code samples:
            var inApp = navigator.userAgent.match(/AppleWebKit/i) != null && navigator.userAgent.match(/Safari/i) == null;
            if (inApp) {
                codeBlocks = document.getElementsByClassName('highlight-python');
                for (var i = 0; i < codeBlocks.length; i++) {
                    codeBlock = codeBlocks[i];
                    if (codeBlock.innerText.indexOf('>>>') == 0) {
                        //Don't add header for interactive sessions
                        continue;
                    }

                    var codeHeader = document.createElement('div');
                    codeHeader.className = 'pythonista-code-header';

                    var copyButton = document.createElement('button');
                    copyButton.className = 'pythonista-button';
                    copyButton.innerText = 'Copy';
                    copyButton.addEventListener('click', copySample.partial(i));
                    codeHeader.appendChild(copyButton);

                    var openButton = document.createElement('button');
                    openButton.className = 'pythonista-button';
                    openButton.innerText = 'Open in Editor';
                    openButton.addEventListener('click', openSample.partial(i));
                    codeHeader.appendChild(openButton);

                    codeBlock.parentElement.insertBefore(codeHeader, codeBlock);
                }
            }
        }
    </script>
    
 

  </head>
  <body ontouchstart="">
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tight_layout_api.html" title="tight_layout"
             accesskey="P">previous</a> |</li>
        <li><a href="../../../pythonista.html"><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -4px; margin-right: 4px;"/></a></li>
        <li><a href="../index.html">Matplotlib 1.3.1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">The Matplotlib API</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="triangular-grids">
<h1>triangular grids<a class="headerlink" href="tri_api.html#triangular-grids" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-matplotlib.tri">
<span id="matplotlib-tri"></span><h2><a class="reference internal" href="tri_api.html#module-matplotlib.tri" title="matplotlib.tri"><tt class="xref py py-mod docutils literal"><span class="pre">matplotlib.tri</span></tt></a><a class="headerlink" href="tri_api.html#module-matplotlib.tri" title="Permalink to this headline">¶</a></h2>
<p>Unstructured triangular grid functions.</p>
<dl class="class">
<dt id="matplotlib.tri.Triangulation">
<em class="property">class </em><tt class="descclassname">matplotlib.tri.</tt><tt class="descname">Triangulation</tt><big>(</big><em>x</em>, <em>y</em>, <em>triangles=None</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="tri_api.html#matplotlib.tri.Triangulation" title="Permalink to this definition">¶</a></dt>
<dd><p>An unstructured triangular grid consisting of npoints points and
ntri triangles.  The triangles can either be specified by the user
or automatically generated using a Delaunay triangulation.</p>
<p>Read-only attributes:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>x</em>: array of shape (npoints).</dt>
<dd>x-coordinates of grid points.</dd>
<dt><em>y</em>: array of shape (npoints).</dt>
<dd>y-coordinates of grid points.</dd>
<dt><em>triangles</em>: integer array of shape (ntri,3).</dt>
<dd>For each triangle, the indices of the three points that make
up the triangle, ordered in an anticlockwise manner.</dd>
<dt><em>mask</em>: optional boolean array of shape (ntri).</dt>
<dd>Which triangles are masked out.</dd>
<dt><em>edges</em>: integer array of shape (?,2).</dt>
<dd>All edges of non-masked triangles.  Each edge is the start
point index and end point index.  Each edge (start,end and
end,start) appears only once.</dd>
<dt><em>neighbors</em>: integer array of shape (ntri,3).</dt>
<dd>For each triangle, the indices of the three triangles that
share the same edges, or -1 if there is no such neighboring
triangle.  neighbors[i,j] is the triangle that is the neighbor
to the edge from point index triangles[i,j] to point index
triangles[i,(j+1)%3].</dd>
</dl>
</div></blockquote>
<p>For a Triangulation to be valid it must not have duplicate points,
triangles formed from colinear points, or overlapping triangles.</p>
<dl class="method">
<dt id="matplotlib.tri.Triangulation.calculate_plane_coefficients">
<tt class="descname">calculate_plane_coefficients</tt><big>(</big><em>z</em><big>)</big><a class="headerlink" href="tri_api.html#matplotlib.tri.Triangulation.calculate_plane_coefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate plane equation coefficients for all unmasked triangles from
the point (x,y) coordinates and specified z-array of shape (npoints).
Returned array has shape (npoints,3) and allows z-value at (x,y)
position in triangle tri to be calculated using
z = array[tri,0]*x + array[tri,1]*y + array[tri,2].</p>
</dd></dl>

<dl class="staticmethod">
<dt id="matplotlib.tri.Triangulation.get_from_args_and_kwargs">
<em class="property">static </em><tt class="descname">get_from_args_and_kwargs</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="tri_api.html#matplotlib.tri.Triangulation.get_from_args_and_kwargs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Triangulation object from the args and kwargs, and
the remaining args and kwargs with the consumed values removed.</p>
<p>There are two alternatives: either the first argument is a
Triangulation object, in which case it is returned, or the args
and kwargs are sufficient to create a new Triangulation to
return.  In the latter case, see Triangulation.__init__ for
the possible args and kwargs.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.tri.Triangulation.get_masked_triangles">
<tt class="descname">get_masked_triangles</tt><big>(</big><big>)</big><a class="headerlink" href="tri_api.html#matplotlib.tri.Triangulation.get_masked_triangles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of triangles that are not masked.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.tri.Triangulation.get_trifinder">
<tt class="descname">get_trifinder</tt><big>(</big><big>)</big><a class="headerlink" href="tri_api.html#matplotlib.tri.Triangulation.get_trifinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default <a class="reference internal" href="tri_api.html#matplotlib.tri.TriFinder" title="matplotlib.tri.TriFinder"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.tri.TriFinder</span></tt></a> of this
triangulation, creating it if necessary.  This allows the same
TriFinder object to be easily shared.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.tri.Triangulation.set_mask">
<tt class="descname">set_mask</tt><big>(</big><em>mask</em><big>)</big><a class="headerlink" href="tri_api.html#matplotlib.tri.Triangulation.set_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Set or clear the mask array.  This is either None, or a boolean
array of shape (ntri).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.tri.TriFinder">
<em class="property">class </em><tt class="descclassname">matplotlib.tri.</tt><tt class="descname">TriFinder</tt><big>(</big><em>triangulation</em><big>)</big><a class="headerlink" href="tri_api.html#matplotlib.tri.TriFinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for classes used to find the triangles of a
Triangulation in which (x,y) points lie.</p>
<p>Rather than instantiate an object of a class derived from TriFinder, it is
usually better to use the function
<a class="reference internal" href="tri_api.html#matplotlib.tri.Triangulation.get_trifinder" title="matplotlib.tri.Triangulation.get_trifinder"><tt class="xref py py-func docutils literal"><span class="pre">matplotlib.tri.Triangulation.get_trifinder()</span></tt></a>.</p>
<p>Derived classes implement __call__(x,y) where x,y are array_like point
coordinates of the same shape.</p>
</dd></dl>

<dl class="class">
<dt id="matplotlib.tri.TrapezoidMapTriFinder">
<em class="property">class </em><tt class="descclassname">matplotlib.tri.</tt><tt class="descname">TrapezoidMapTriFinder</tt><big>(</big><em>triangulation</em><big>)</big><a class="headerlink" href="tri_api.html#matplotlib.tri.TrapezoidMapTriFinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">matplotlib.tri.trifinder.TriFinder</span></tt></p>
<p><a class="reference internal" href="tri_api.html#matplotlib.tri.TriFinder" title="matplotlib.tri.TriFinder"><tt class="xref py py-class docutils literal"><span class="pre">TriFinder</span></tt></a> class implemented using the trapezoid
map algorithm from the book &#8220;Computational Geometry, Algorithms and
Applications&#8221;, second edition, by M. de Berg, M. van Kreveld, M. Overmars
and O. Schwarzkopf.</p>
<p>The triangulation must be valid, i.e. it must not have duplicate points,
triangles formed from colinear points, or overlapping triangles.  The
algorithm has some tolerance to triangles formed from colinear points, but
this should not be relied upon.</p>
<dl class="method">
<dt id="matplotlib.tri.TrapezoidMapTriFinder.__call__">
<tt class="descname">__call__</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="tri_api.html#matplotlib.tri.TrapezoidMapTriFinder.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array containing the indices of the triangles in which the
specified x,y points lie, or -1 for points that do not lie within a
triangle.</p>
<p><em>x</em>, <em>y</em> are array_like x and y coordinates of the same shape and any
number of dimensions.</p>
<p>Returns integer array with the same shape and <em>x</em> and <em>y</em>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.tri.TriInterpolator">
<em class="property">class </em><tt class="descclassname">matplotlib.tri.</tt><tt class="descname">TriInterpolator</tt><big>(</big><em>triangulation</em>, <em>z</em>, <em>trifinder=None</em><big>)</big><a class="headerlink" href="tri_api.html#matplotlib.tri.TriInterpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for classes used to perform interpolation on
triangular grids.</p>
<p>Derived classes implement the following methods:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">__call__(x,</span> <span class="pre">y)</span></tt> ,
where x, y are array_like point coordinates of the same shape, and
that returns a masked array of the same shape containing the
interpolated z-values.</li>
<li><tt class="docutils literal"><span class="pre">gradient(x,</span> <span class="pre">y)</span></tt> ,
where x, y are array_like point coordinates of the same
shape, and that returns a list of 2 masked arrays of the same shape
containing the 2 derivatives of the interpolator (derivatives of
interpolated z values with respect to x and y).</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="matplotlib.tri.LinearTriInterpolator">
<em class="property">class </em><tt class="descclassname">matplotlib.tri.</tt><tt class="descname">LinearTriInterpolator</tt><big>(</big><em>triangulation</em>, <em>z</em>, <em>trifinder=None</em><big>)</big><a class="headerlink" href="tri_api.html#matplotlib.tri.LinearTriInterpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">matplotlib.tri.triinterpolate.TriInterpolator</span></tt></p>
<p>A LinearTriInterpolator performs linear interpolation on a triangular grid.</p>
<p>Each triangle is represented by a plane so that an interpolated value at
point (x,y) lies on the plane of the triangle containing (x,y).
Interpolated values are therefore continuous across the triangulation, but
their first derivatives are discontinuous at edges between triangles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>triangulation</strong> : <a class="reference internal" href="tri_api.html#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><tt class="xref py py-class docutils literal"><span class="pre">Triangulation</span></tt></a> object</p>
<blockquote>
<div><p>The triangulation to interpolate over.</p>
</div></blockquote>
<p><strong>z</strong> : array_like of shape (npoints,)</p>
<blockquote>
<div><p>Array of values, defined at grid points, to interpolate between.</p>
</div></blockquote>
<p><strong>trifinder</strong> : <a class="reference internal" href="tri_api.html#matplotlib.tri.TriFinder" title="matplotlib.tri.TriFinder"><tt class="xref py py-class docutils literal"><span class="pre">TriFinder</span></tt></a> object, optional</p>
<blockquote class="last">
<div><p>If this is not specified, the Triangulation&#8217;s default TriFinder will
be used by calling
<a class="reference internal" href="tri_api.html#matplotlib.tri.Triangulation.get_trifinder" title="matplotlib.tri.Triangulation.get_trifinder"><tt class="xref py py-func docutils literal"><span class="pre">matplotlib.tri.Triangulation.get_trifinder()</span></tt></a>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="63%" />
<col width="14%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="tri_api.html#matplotlib.tri.LinearTriInterpolator.__call__" title="matplotlib.tri.LinearTriInterpolator.__call__"><tt class="xref py py-obj docutils literal"><span class="pre">__call__</span></tt></a> (x, y)</td>
<td>Returns interpolated values at x,y points</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="tri_api.html#matplotlib.tri.LinearTriInterpolator.gradient" title="matplotlib.tri.LinearTriInterpolator.gradient"><tt class="xref py py-obj docutils literal"><span class="pre">gradient</span></tt></a> (x, y)</td>
<td>Returns interpolated derivatives at x,y points</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="matplotlib.tri.LinearTriInterpolator.__call__">
<tt class="descname">__call__</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="tri_api.html#matplotlib.tri.LinearTriInterpolator.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a masked array containing interpolated values at the specified
x,y points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x, y</strong> : array-like</p>
<blockquote>
<div><p>x and y coordinates of the same shape and any number of
dimensions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>z</strong> : np.ma.array</p>
<blockquote class="last">
<div><p>Masked array of the same shape as <em>x</em> and <em>y</em> ; values
corresponding to (<em>x</em>, <em>y</em>) points outside of the triangulation
are masked out.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="matplotlib.tri.LinearTriInterpolator.gradient">
<tt class="descname">gradient</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="tri_api.html#matplotlib.tri.LinearTriInterpolator.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of 2 masked arrays containing interpolated derivatives
at the specified x,y points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x, y</strong> : array-like</p>
<blockquote>
<div><p>x and y coordinates of the same shape and any number of
dimensions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dzdx, dzdy</strong> : np.ma.array</p>
<blockquote class="last">
<div><p>2  masked arrays of the same shape as <em>x</em> and <em>y</em> ; values
corresponding to (x,y) points outside of the triangulation
are masked out.
The first returned array contains the values of
<img src="../_images/mathmpl/math-c05929fd30.png" style="position: relative; bottom: -10px"/> and the second those of
<img src="../_images/mathmpl/math-99abe4d704.png" style="position: relative; bottom: -13px"/>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.tri.CubicTriInterpolator">
<em class="property">class </em><tt class="descclassname">matplotlib.tri.</tt><tt class="descname">CubicTriInterpolator</tt><big>(</big><em>triangulation</em>, <em>z</em>, <em>kind='min_E'</em>, <em>trifinder=None</em>, <em>dz=None</em><big>)</big><a class="headerlink" href="tri_api.html#matplotlib.tri.CubicTriInterpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">matplotlib.tri.triinterpolate.TriInterpolator</span></tt></p>
<p>A CubicTriInterpolator performs cubic interpolation on triangular grids.</p>
<p>In one-dimension - on a segment - a cubic interpolating function is
defined by the values of the function and its derivative at both ends.
This is almost the same in 2-d inside a triangle, except that the values
of the function and its 2 derivatives have to be defined at each triangle
node.</p>
<p>The CubicTriInterpolator takes the value of the function at each node -
provided by the user - and internally computes the value of the
derivatives, resulting in a smooth interpolation.
(As a special feature, the user can also impose the value of the
derivatives at each node, but this is not supposed to be the common
usage.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>triangulation</strong> : <a class="reference internal" href="tri_api.html#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><tt class="xref py py-class docutils literal"><span class="pre">Triangulation</span></tt></a> object</p>
<blockquote>
<div><p>The triangulation to interpolate over.</p>
</div></blockquote>
<p><strong>z</strong> : array_like of shape (npoints,)</p>
<blockquote>
<div><p>Array of values, defined at grid points, to interpolate between.</p>
</div></blockquote>
<p><strong>kind</strong> : {&#8216;min_E&#8217;, &#8216;geom&#8217;, &#8216;user&#8217;}, optional</p>
<blockquote>
<div><p>Choice of the smoothing algorithm, in order to compute
the interpolant derivatives (defaults to &#8216;min_E&#8217;):</p>
<blockquote>
<div><ul class="simple">
<li>if &#8216;min_E&#8217;: (default) The derivatives at each node is computed
to minimize a bending energy.</li>
<li>if &#8216;geom&#8217;: The derivatives at each node is computed as a
weighted average of relevant triangle normals. To be used for
speed optimization (large grids).</li>
<li>if &#8216;user&#8217;: The user provides the argument <tt class="xref py py-obj docutils literal"><span class="pre">dz</span></tt>, no computation
is hence needed.</li>
</ul>
</div></blockquote>
</div></blockquote>
<p><strong>trifinder</strong> : <a class="reference internal" href="tri_api.html#matplotlib.tri.TriFinder" title="matplotlib.tri.TriFinder"><tt class="xref py py-class docutils literal"><span class="pre">TriFinder</span></tt></a> object, optional</p>
<blockquote>
<div><p>If not specified, the Triangulation&#8217;s default TriFinder will
be used by calling
<a class="reference internal" href="tri_api.html#matplotlib.tri.Triangulation.get_trifinder" title="matplotlib.tri.Triangulation.get_trifinder"><tt class="xref py py-func docutils literal"><span class="pre">matplotlib.tri.Triangulation.get_trifinder()</span></tt></a>.</p>
</div></blockquote>
<p><strong>dz</strong> : tuple of array_likes (dzdx, dzdy), optional</p>
<blockquote class="last">
<div><p>Used only if  <em>kind</em> =&#8217;user&#8217;. In this case <em>dz</em> must be provided as
(dzdx, dzdy) where dzdx, dzdy are arrays of the same shape as <em>z</em> and
are the interpolant first derivatives at the <em>triangulation</em> points.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This note is a bit technical and details the way a
<a class="reference internal" href="tri_api.html#matplotlib.tri.CubicTriInterpolator" title="matplotlib.tri.CubicTriInterpolator"><tt class="xref py py-class docutils literal"><span class="pre">CubicTriInterpolator</span></tt></a> computes a cubic
interpolation.</p>
<p>The interpolation is based on a Clough-Tocher subdivision scheme of
the <em>triangulation</em> mesh (to make it clearer, each triangle of the
grid will be divided in 3 child-triangles, and on each child triangle
the interpolated function is a cubic polynomial of the 2 coordinates).
This technique originates from FEM (Finite Element Method) analysis;
the element used is a reduced Hsieh-Clough-Tocher (HCT)
element. Its shape functions are described in <a class="reference internal" href="tri_api.html#r1" id="id1">[R1]</a>.
The assembled function is guaranteed to be C1-smooth, i.e. it is
continuous and its first derivatives are also continuous (this
is easy to show inside the triangles but is also true when crossing the
edges).</p>
<p>In the default case (<em>kind</em> =&#8217;min_E&#8217;), the interpolant minimizes a
curvature energy on the functional space generated by the HCT element
shape functions - with imposed values but arbitrary derivatives at each
node. The minimized functional is the integral of the so-called total
curvature (implementation based on an algorithm from <a class="reference internal" href="tri_api.html#r2" id="id2">[R2]</a> - PCG sparse
solver):</p>
<blockquote>
<div><img src="../_images/mathmpl/math-4d96f7ca18.png" class="center" /></div></blockquote>
<p>If the case <em>kind</em> =&#8217;geom&#8217; is chosen by the user, a simple geometric
approximation is used (weighted average of the triangle normal
vectors), which could improve speed on very large grids.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R1]</td><td><em>(<a class="fn-backref" href="tri_api.html#id1">1</a>, <a class="fn-backref" href="tri_api.html#id3">2</a>)</em> Michel Bernadou, Kamal Hassan, &#8220;Basis functions for general
Hsieh-Clough-Tocher triangles, complete or reduced.&#8221;,
International Journal for Numerical Methods in Engineering,
17(5):784 - 789. 2.01.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R2]</td><td><em>(<a class="fn-backref" href="tri_api.html#id2">1</a>, <a class="fn-backref" href="tri_api.html#id4">2</a>)</em> C.T. Kelley, &#8220;Iterative Methods for Optimization&#8221;.</td></tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="63%" />
<col width="14%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="tri_api.html#matplotlib.tri.CubicTriInterpolator.__call__" title="matplotlib.tri.CubicTriInterpolator.__call__"><tt class="xref py py-obj docutils literal"><span class="pre">__call__</span></tt></a> (x, y)</td>
<td>Returns interpolated values at x,y points</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="tri_api.html#matplotlib.tri.CubicTriInterpolator.gradient" title="matplotlib.tri.CubicTriInterpolator.gradient"><tt class="xref py py-obj docutils literal"><span class="pre">gradient</span></tt></a> (x, y)</td>
<td>Returns interpolated derivatives at x,y points</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="matplotlib.tri.CubicTriInterpolator.__call__">
<tt class="descname">__call__</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="tri_api.html#matplotlib.tri.CubicTriInterpolator.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a masked array containing interpolated values at the specified
x,y points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x, y</strong> : array-like</p>
<blockquote>
<div><p>x and y coordinates of the same shape and any number of
dimensions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>z</strong> : np.ma.array</p>
<blockquote class="last">
<div><p>Masked array of the same shape as <em>x</em> and <em>y</em> ; values
corresponding to (<em>x</em>, <em>y</em>) points outside of the triangulation
are masked out.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="matplotlib.tri.CubicTriInterpolator.gradient">
<tt class="descname">gradient</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="tri_api.html#matplotlib.tri.CubicTriInterpolator.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of 2 masked arrays containing interpolated derivatives
at the specified x,y points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x, y</strong> : array-like</p>
<blockquote>
<div><p>x and y coordinates of the same shape and any number of
dimensions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dzdx, dzdy</strong> : np.ma.array</p>
<blockquote class="last">
<div><p>2  masked arrays of the same shape as <em>x</em> and <em>y</em> ; values
corresponding to (x,y) points outside of the triangulation
are masked out.
The first returned array contains the values of
<img src="../_images/mathmpl/math-c05929fd30.png" style="position: relative; bottom: -10px"/> and the second those of
<img src="../_images/mathmpl/math-99abe4d704.png" style="position: relative; bottom: -13px"/>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>An example of effective application is shown below (plot of the
direction of the vector field derivated from a known potential field):</p>
<p>(<a class="reference external" href="http://omz-software.com/pythonista/matplotlib/mpl_examples/pylab_examples/trigradient_demo.py">Source code</a>, <a class="reference external" href="http://omz-software.com/pythonista/matplotlib/mpl_examples/pylab_examples/trigradient_demo.png">png</a>)</p>
<div class="figure">
<img alt="../_images/trigradient_demo.png" src="../_images/trigradient_demo.png" />
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.tri.TriRefiner">
<em class="property">class </em><tt class="descclassname">matplotlib.tri.</tt><tt class="descname">TriRefiner</tt><big>(</big><em>triangulation</em><big>)</big><a class="headerlink" href="tri_api.html#matplotlib.tri.TriRefiner" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for classes implementing mesh refinement.</p>
<p>A TriRefiner encapsulates a Triangulation object and provides tools for
mesh refinement and interpolation.</p>
<p>Derived classes must implements:</p>
<blockquote>
<div><ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">refine_triangulation(return_tri_index=False,</span> <span class="pre">**kwargs)</span></tt> , where
the optional keyword arguments <em>kwargs</em> are defined in each
TriRefiner concrete implementation, and which returns :</p>
<blockquote>
<div><ul class="simple">
<li>a refined triangulation</li>
<li>optionally (depending on <em>return_tri_index</em>), for each
point of the refined triangulation: the index of
the initial triangulation triangle to which it belongs.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">refine_field(z,</span> <span class="pre">triinterpolator=None,</span> <span class="pre">**kwargs)</span></tt> , where:</p>
<blockquote>
<div><ul class="simple">
<li><em>z</em> array of field values (to refine) defined at the base
triangulation nodes</li>
<li><em>triinterpolator</em> is a
<a class="reference internal" href="tri_api.html#matplotlib.tri.TriInterpolator" title="matplotlib.tri.TriInterpolator"><tt class="xref py py-class docutils literal"><span class="pre">TriInterpolator</span></tt></a> (optional)</li>
<li>the other optional keyword arguments <em>kwargs</em> are defined in
each TriRefiner concrete implementation</li>
</ul>
</div></blockquote>
<p>and which returns (as a tuple) a refined triangular mesh and the
interpolated values of the field at the refined triangulation nodes.</p>
</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="matplotlib.tri.UniformTriRefiner">
<em class="property">class </em><tt class="descclassname">matplotlib.tri.</tt><tt class="descname">UniformTriRefiner</tt><big>(</big><em>triangulation</em><big>)</big><a class="headerlink" href="tri_api.html#matplotlib.tri.UniformTriRefiner" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">matplotlib.tri.trirefine.TriRefiner</span></tt></p>
<p>Uniform mesh refinement by recursive subdivisions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>triangulation</strong> : <a class="reference internal" href="tri_api.html#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><tt class="xref py py-class docutils literal"><span class="pre">Triangulation</span></tt></a></p>
<blockquote class="last">
<div><p>The encapsulated triangulation (to be refined)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="matplotlib.tri.UniformTriRefiner.refine_field">
<tt class="descname">refine_field</tt><big>(</big><em>z</em>, <em>triinterpolator=None</em>, <em>subdiv=3</em><big>)</big><a class="headerlink" href="tri_api.html#matplotlib.tri.UniformTriRefiner.refine_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Refines a field defined on the encapsulated triangulation.</p>
<p>Returns <em>refi_tri</em> (refined triangulation), <em>refi_z</em> (interpolated
values of the field at the node of the refined triangulation).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>z</strong> : 1d-array-like of length <tt class="docutils literal"><span class="pre">n_points</span></tt></p>
<blockquote>
<div><p>Values of the field to refine, defined at the nodes of the
encapsulated triangulation. (<tt class="docutils literal"><span class="pre">n_points</span></tt> is the number of points
in the initial triangulation)</p>
</div></blockquote>
<p><strong>triinterpolator</strong> : <a class="reference internal" href="tri_api.html#matplotlib.tri.TriInterpolator" title="matplotlib.tri.TriInterpolator"><tt class="xref py py-class docutils literal"><span class="pre">TriInterpolator</span></tt></a>, optional</p>
<blockquote>
<div><p>Interpolator used for field interpolation. If not specified,
a <a class="reference internal" href="tri_api.html#matplotlib.tri.CubicTriInterpolator" title="matplotlib.tri.CubicTriInterpolator"><tt class="xref py py-class docutils literal"><span class="pre">CubicTriInterpolator</span></tt></a> will
be used.</p>
</div></blockquote>
<p><strong>subdiv</strong> : integer, optional</p>
<blockquote>
<div><p>Recursion level for the subdivision. Defaults to 3.
Each triangle will be divided into <tt class="docutils literal"><span class="pre">4**subdiv</span></tt> child triangles.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>refi_tri</strong> : <a class="reference internal" href="tri_api.html#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><tt class="xref py py-class docutils literal"><span class="pre">Triangulation</span></tt></a> object</p>
<blockquote>
<div><p>The returned refined triangulation</p>
</div></blockquote>
<p><strong>refi_z</strong> : 1d array of length: <em>refi_tri</em> node count.</p>
<blockquote class="last">
<div><p>The returned interpolated field (at <em>refi_tri</em> nodes)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>The main application of this method is to plot high-quality
iso-contours on a coarse triangular grid (e.g., triangulation built
from relatively sparse test data):</p>
<p>(<a class="reference external" href="http://omz-software.com/pythonista/matplotlib/mpl_examples/pylab_examples/tricontour_smooth_user.py">Source code</a>, <a class="reference external" href="../mpl_examples/pylab_examples/tricontour_smooth_user.png">png</a>)</p>
<div class="figure">
<img alt="../_images/tricontour_smooth_user.png" src="../_images/tricontour_smooth_user.png" />
</div>
</dd></dl>

<dl class="method">
<dt id="matplotlib.tri.UniformTriRefiner.refine_triangulation">
<tt class="descname">refine_triangulation</tt><big>(</big><em>return_tri_index=False</em>, <em>subdiv=3</em><big>)</big><a class="headerlink" href="tri_api.html#matplotlib.tri.UniformTriRefiner.refine_triangulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes an uniformly refined triangulation <em>refi_triangulation</em> of
the encapsulated <tt class="xref py py-attr docutils literal"><span class="pre">triangulation</span></tt>.</p>
<p>This function refines the encapsulated triangulation by splitting each
father triangle into 4 child sub-triangles built on the edges midside
nodes, recursively (level of recursion <em>subdiv</em>).
In the end, each triangle is hence divided into <tt class="docutils literal"><span class="pre">4**subdiv</span></tt>
child triangles.
The default value for <em>subdiv</em> is 3 resulting in 64 refined
subtriangles for each triangle of the initial triangulation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>return_tri_index</strong> : boolean, optional</p>
<blockquote>
<div><p>Boolean indicating whether an index table indicating the father
triangle index of each point will be returned. Default value
False.</p>
</div></blockquote>
<p><strong>subdiv</strong> : integer, optional</p>
<blockquote>
<div><p>Recursion level for the subdivision. Defaults value 3.
Each triangle will be divided into <tt class="docutils literal"><span class="pre">4**subdiv</span></tt> child triangles.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>refi_triangulation</strong> : <a class="reference internal" href="tri_api.html#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><tt class="xref py py-class docutils literal"><span class="pre">Triangulation</span></tt></a></p>
<blockquote>
<div><p>The returned refined triangulation</p>
</div></blockquote>
<p><strong>found_index</strong> : array-like of integers</p>
<blockquote class="last">
<div><p>Index of the initial triangulation containing triangle, for each
point of <em>refi_triangulation</em>.
Returned only if <em>return_tri_index</em> is set to True.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.tri.TriAnalyzer">
<em class="property">class </em><tt class="descclassname">matplotlib.tri.</tt><tt class="descname">TriAnalyzer</tt><big>(</big><em>triangulation</em><big>)</big><a class="headerlink" href="tri_api.html#matplotlib.tri.TriAnalyzer" title="Permalink to this definition">¶</a></dt>
<dd><p>Define basic tools for triangular mesh analysis and improvement.</p>
<p>A TriAnalizer encapsulates a <a class="reference internal" href="tri_api.html#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><tt class="xref py py-class docutils literal"><span class="pre">Triangulation</span></tt></a>
object and provides basic tools for mesh analysis and mesh improvement.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>triangulation</strong> : <a class="reference internal" href="tri_api.html#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><tt class="xref py py-class docutils literal"><span class="pre">Triangulation</span></tt></a> object</p>
<blockquote class="last">
<div><p>The encapsulated triangulation to analyze.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="tri_api.html#matplotlib.tri.TriAnalyzer.scale_factors" title="matplotlib.tri.TriAnalyzer.scale_factors"><tt class="xref py py-obj docutils literal"><span class="pre">scale_factors</span></tt></a></td>
<td>Factors to rescale the triangulation into a unit square.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="matplotlib.tri.TriAnalyzer.circle_ratios">
<tt class="descname">circle_ratios</tt><big>(</big><em>rescale=True</em><big>)</big><a class="headerlink" href="tri_api.html#matplotlib.tri.TriAnalyzer.circle_ratios" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a measure of the triangulation triangles flatness.</p>
<p>The ratio of the incircle radius over the circumcircle radius is a
widely used indicator of a triangle flatness.
It is always <tt class="docutils literal"><span class="pre">&lt;=</span> <span class="pre">0.5</span></tt> and <tt class="docutils literal"><span class="pre">==</span> <span class="pre">0.5</span></tt> only for equilateral
triangles. Circle ratios below 0.01 denote very flat triangles.</p>
<p>To avoid unduly low values due to a difference of scale between the 2
axis, the triangular mesh can first be rescaled to fit inside a unit
square with <a class="reference internal" href="tri_api.html#matplotlib.tri.TriAnalyzer.scale_factors" title="matplotlib.tri.TriAnalyzer.scale_factors"><tt class="xref py py-attr docutils literal"><span class="pre">scale_factors</span></tt></a> (Only if <em>rescale</em> is True, which is
its default value).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rescale</strong> : boolean, optional</p>
<blockquote>
<div><p>If True, a rescaling will be internally performed (based on
<a class="reference internal" href="tri_api.html#matplotlib.tri.TriAnalyzer.scale_factors" title="matplotlib.tri.TriAnalyzer.scale_factors"><tt class="xref py py-attr docutils literal"><span class="pre">scale_factors</span></tt></a>, so that the (unmasked) triangles fit
exactly inside a unit square mesh. Default is True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>circle_ratios</strong> : masked array</p>
<blockquote class="last">
<div><p>Ratio of the incircle radius over the
circumcircle radius, for each &#8216;rescaled&#8217; triangle of the
encapsulated triangulation.
Values corresponding to masked triangles are masked out.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="matplotlib.tri.TriAnalyzer.get_flat_tri_mask">
<tt class="descname">get_flat_tri_mask</tt><big>(</big><em>min_circle_ratio=0.01</em>, <em>rescale=True</em><big>)</big><a class="headerlink" href="tri_api.html#matplotlib.tri.TriAnalyzer.get_flat_tri_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Eliminates excessively flat border triangles from the triangulation.</p>
<p>Returns a mask <em>new_mask</em> which allows to clean the encapsulated
triangulation from its border-located flat triangles
(according to their <a class="reference internal" href="tri_api.html#matplotlib.tri.TriAnalyzer.circle_ratios" title="matplotlib.tri.TriAnalyzer.circle_ratios"><tt class="xref py py-meth docutils literal"><span class="pre">circle_ratios()</span></tt></a>).
This mask is meant to be subsequently applied to the triangulation
using <a class="reference internal" href="tri_api.html#matplotlib.tri.Triangulation.set_mask" title="matplotlib.tri.Triangulation.set_mask"><tt class="xref py py-func docutils literal"><span class="pre">matplotlib.tri.Triangulation.set_mask()</span></tt></a> .
<em>new_mask</em> is an extension of the initial triangulation mask
in the sense that an initially masked triangle will remain masked.</p>
<p>The <em>new_mask</em> array is computed recursively ; at each step flat
triangles are removed only if they share a side with the current
mesh border. Thus no new holes in the triangulated domain will be
created.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>min_circle_ratio</strong> : float, optional</p>
<blockquote>
<div><p>Border triangles with incircle/circumcircle radii ratio r/R will
be removed if r/R &lt; <em>min_circle_ratio</em>. Default value: 0.01</p>
</div></blockquote>
<p><strong>rescale</strong> : boolean, optional</p>
<blockquote>
<div><p>If True, a rescaling will first be internally performed (based on
<a class="reference internal" href="tri_api.html#matplotlib.tri.TriAnalyzer.scale_factors" title="matplotlib.tri.TriAnalyzer.scale_factors"><tt class="xref py py-attr docutils literal"><span class="pre">scale_factors</span></tt></a> ), so that the (unmasked) triangles fit
exactly inside a unit square mesh. This rescaling accounts for the
difference of scale which might exist between the 2 axis. Default
(and recommended) value is True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>new_mask</strong> : array-like of booleans</p>
<blockquote class="last">
<div><p>Mask to apply to encapsulated triangulation.
All the initially masked triangles remain masked in the
<em>new_mask</em>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The rationale behind this function is that a Delaunay
triangulation - of an unstructured set of points - sometimes contains
almost flat triangles at its border, leading to artifacts in plots
(especially for high-resolution contouring).
Masked with computed <em>new_mask</em>, the encapsulated
triangulation would contain no more unmasked border triangles
with a circle ratio below <em>min_circle_ratio</em>, thus improving the
mesh quality for subsequent plots or interpolation.</p>
<p class="rubric">Examples</p>
<p>Please refer to the following illustrating example:</p>
<p>(<a class="reference external" href="http://omz-software.com/pythonista/matplotlib/mpl_examples/pylab_examples/tricontour_smooth_delaunay.py">Source code</a>, <a class="reference external" href="http://omz-software.com/pythonista/matplotlib/mpl_examples/pylab_examples/tricontour_smooth_delaunay.png">png</a>)</p>
<div class="figure">
<img alt="../_images/tricontour_smooth_delaunay.png" src="../_images/tricontour_smooth_delaunay.png" />
</div>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.tri.TriAnalyzer.scale_factors">
<tt class="descname">scale_factors</tt><a class="headerlink" href="tri_api.html#matplotlib.tri.TriAnalyzer.scale_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Factors to rescale the triangulation into a unit square.</p>
<p>Returns <em>k</em>, tuple of 2 scale factors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>k</strong> : tuple of 2 floats (kx, ky)</p>
<blockquote class="last">
<div><p>Tuple of floats that would rescale the triangulation :
<tt class="docutils literal"><span class="pre">[triangulation.x</span> <span class="pre">*</span> <span class="pre">kx,</span> <span class="pre">triangulation.y</span> <span class="pre">*</span> <span class="pre">ky]</span></tt>
fits exactly inside a unit square.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
    &copy; <a href="http://omz-software.com/pythonista/matplotlib/copyright.html">Copyright</a> 2002 - 2012 John Hunter, Darren Dale, Eric Firing, Michael Droettboom and the matplotlib development team; 2012 - 2013 The matplotlib development team.
    <br />
    The Python Software Foundation is a non-profit corporation.  
    <a href="http://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on May 03, 2016.
    <a href="http://omz-software.com/pythonista/matplotlib/bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.1.
    </div>

  </body>
</html>